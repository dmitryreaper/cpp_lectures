
# Table of Contents

1.  [1. Перечислите и охарактеризуйте стадии разработки программного обеспечения](#org799df60)
    1.  [Анализ требований:](#org3cb9f01)
    2.  [Проектирование (дизайн):](#orgb104a00)
    3.  [Реализация (кодирование):](#org5191419)
    4.  [Тестирование:](#orga11c5e3)
    5.  [Интеграция и деплоймент:](#org5018a8f)
    6.  [Эксплуатация и сопровождение:](#org77d4a5b)
    7.  [Завершение проекта:](#orgf791b4c)
2.  [2. Раскройте понятие алгоритм, перечислите и охарактеризуйте свойства алгоритмов](#org4b88707)
    1.  [Свойства алгоритмов:](#org26a208e)
    2.  [Примеры некоторых алгоритмов из STL в C++:](#org7d5a688)
3.  [3. Раскройте понятие алгоритм, перечислите и охарактеризуйте способы описания алгоритмов](#orgf1ae721)
        1.  [Способы описания алгоритмов на примере C++:](#org3bd6264)
4.  [4. Раскройте понятие алгоритм, перечислите и охарактеризуйте виды алгоритмов](#orgc8d5f3f)
        1.  [Виды алгоритмов и их характеристика:](#orga0f4d89)
5.  [5. Раскройте понятие тип данных, перечислите основные встроенные типы данных](#org2766bf0)
        1.  [Основные встроенные типы данных в C++](#org4dbac64)
        2.  [Примеры использования основных типов данных в C++](#orgc16438b)
6.  [6. Перечислите и охарактеризуйте основные структурные элементы программы](#org10ac363)
        1.  [Заголовочные файлы](#orga8e4a6f)
        2.  [Пространства имен (namespaces)](#orgc82d60a)
        3.  [Функции](#orgf274095)
        4.  [Переменные](#orgc70a252)
        5.  [Операторы](#org2184532)
        6.  [Управляющие структуры](#org25470df)
        7.  [Классы и объекты](#orgcbad15c)
        8.  [Комментарии](#org3fad6f3)
        9.  [Константы](#org300894c)
        10. [Предпроцессорные директивы](#org0ae15d5)
7.  [7. Раскройте понятие оператор, перечислите и охарактеризуйте виды операторов](#orged645ba)
        1.  [Понятие оператора](#org5b7ac0a)
        2.  [Виды операторов и их характеристика](#org24a8da4)
8.  [8. Перечислите и приведите примеры операторов организации циклов](#org3487c5e)
        1.  [Цикл for](#orga5f8f43)
        2.  [Цикл while](#org91a0691)
        3.  [Цикл do while](#orgcab57ad)
        4.  [Операторы управления циклами](#org4eb8911)
9.  [9. Перечислите и приведите примеры условных операторов](#org3a06bd0)
10. [10. Раскройте понятие итерационный алгоритм, охарактеризуйте порядок выполнения](#org3578599)
        1.  [Порядок выполнения итерационного алгоритма:](#orgdc397cc)
11. [11. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания одномерных массивов](#org2d79372)
        1.  [Примеры описания одномерных массивов на C++](#orgcdd2c86)
12. [12. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания массивов массивов](#org7302659)
        1.  [Примеры описания массивов массивов (двумерных массивов) на C++:](#org71bc7e4)
13. [13. Раскройте понятие процедура и функция, перечислите ключевые особенности](#org758fde6)
14. [14. Раскройте понятие процедура и функция, приведите классификацию параметров](#orgdf959e1)
        1.  [1. По направлению передачи данных:](#org7bf194f)
        2.  [2. По типу передачи:](#org7d8abb5)
        3.  [3. По наличию значений по умолчанию:](#orgb93aafb)
15. [15. Раскройте суть метода пошаговой детализации разработки алгоритмов](#org68183ee)
        1.  [Основные шаги метода пошаговой детализации](#orga23fe13)
        2.  [Пример применения метода пошаговой детализации на C++:](#org8c81cdc)
        3.  [Преимущества метода пошаговой детализации:](#org96a09c7)
16. [16. Раскройте понятие строка и символьная переменная, приведите примеры объявлений](#orgc8f70f8)
        1.  [Строка](#org8f0128c)
        2.  [Символьная переменная](#org47f4954)
17. [17. Перечислите основные функции обработки строк, приведите пример использования](#org38ee1ba)
        1.  [Основные функции и методы обработки строк:](#org84e4633)
        2.  [Пример использования основных функций обработки строк:](#orgd45992d)
18. [18. Раскройте понятие множество, перечислите операции над множествами](#orgf77e4b9)
    1.  [Основные операции над множествами](#orgceb1578)
    2.  [Пример использования операций над множествами на C++](#org13dcaf2)
19. [19. Раскройте понятие множество, перечислите ключевые особенности множества и мультимножества](#org14beaad)
    1.  [Множество](#org343c317)
    2.  [Мультимножество](#org1d7fdb5)
20. [20. Раскройте понятие строка, перечислите основные операции над строками](#org07b8ee2)
        1.  [Строка](#org2ac6055)
21. [21. Раскройте понятие сортировка, перечислите виды сортировок.](#org9ae64a9)
    1.  [Понятие сортировка](#org28e1aa1)
    2.  [Виды сортировок](#org5c15e0a)
    3.  [Краткое описание и примеры алгоритмов сортировки](#org6feeaa1)
        1.  [1. Пузырьковая сортировка (Bubble Sort)](#org05b092d)
        2.  [2. Сортировка вставками (Insertion Sort)](#org1708f23)
        3.  [3. Сортировка выбором (Selection Sort)](#org32cf477)
        4.  [4. Сортировка слиянием (Merge Sort)](#org7557bae)
22. [22. Охарактеризуйте сортировку обменом, перечислите основные алгоритмы обменных сортировок](#org22e94de)
    1.  [Сортировка обменом](#org7903d19)
    2.  [Основные алгоритмы обменных сортировок](#orga23469e)
        1.  [1. Пузырьковая сортировка (Bubble Sort)](#org896b435)
        2.  [2. Шейкерная сортировка (Cocktail Shaker Sort)](#org1a75ae9)
        3.  [3. Сортировка Шелла (Shell Sort)](#orgd391f57)
        4.  [4. Быстрая сортировка (Quick Sort)](#orge37cb27)
23. [23. Охарактеризуйте сортировку вставками, перечислите основные алгоритмы сортировоквставками](#orgc8601f9)
24. [24. Охарактеризуйте сортировку выбором, перечислите основные алгоритмы сортировок выбором](#org94db4b4)
25. [25. Раскройте понятие структура, приведите пример описания](#org9da6d09)
26. [26. Раскройте понятие структура, приведите пример обращения к элементам структуры](#org6d26e38)
27. [27. Раскройте понятие объединение, приведите пример описания](#orgc061344)
28. [28. Раскройте понятие объединение, перечислите ключевые отличия от структуры](#org323f529)
29. [29. Раскройте понятие перечисление, приведите пример объявления](#org8cefbf9)
30. [30. Раскройте понятие файл, перечислите и охарактеризуйте виды файлов](#orgb72a5ba)
31. [31. Раскройте понятие файл, перечислите и охарактеризуйте способы доступа к файлам](#org5a71f40)
32. [32. Раскройте понятие файл, приведите пример объявления файловой переменной](#orga0bb98f)
33. [33. Раскройте понятия рекурсия, шаг рекурсии](#orgb2fe350)
34. [34. Раскройте понятие рекурсия, перечислите виды рекурсивных функций](#orgc7d89a4)
35. [35. Раскройте понятие рекурсия, перечислите ключевые особенности объявления и использования рекурсивных функций](#orgb754e89)
36. [36. Раскройте понятие объектно-ориентированное программирование, перечислите основные свойства ООП](#org0b93730)
37. [37. Перечислите и охарактеризуйте основные свойства ООП](#org65a737f)
38. [38. Раскройте понятие класс, приведите пример объявления, охарактеризуйте основные элементы](#org541b18f)
39. [39. Раскройте понятие класс, приведите пример объявления объектов класса и обращения к элементам класса](#org5fac11d)
40. [40. Раскройте понятие объект, класс, конструктор, деструктор](#org09d18d7)
41. [41. Раскройте понятие наследование, приведите пример наследования классов](#org7bb11cd)
42. [42. Охарактеризуйте особенности вызова и передачи аргументов конструктора и деструктора при наследовании](#org08a13c1)
43. [43. Охарактеризуйте понятие динамическая библиотека, назначение и использование](#org9d530df)
44. [44. Раскройте понятие динамические структуры данных, их назначение и использование](#org239c0e7)
45. [45. Перечислите динамические структуры данных, охарактеризуйте структуру стек](#org8926a10)
46. [46. Перечислите динамические структуры данных, охарактеризуйте структуру односвязный список](#org1f28a5b)
47. [47. Перечислите динамические структуры данных, охарактеризуйте структуру двусвязный список](#orgd3d1054)
48. [48. Перечислите динамические структуры данных, охарактеризуйте структуру очередь](#orgdea1fdc)
49. [49. Перечислите динамические структуры данных, охарактеризуйте структуру двоичное дерево](#orge3bdb70)
50. [50. Перечислите способы обхода деревьев](#org41e78e2)
51. [51. Перечислите динамические структуры данных, охарактеризуйте структуру кольцо](#org029c16c)
52. [52. Раскройте понятие хеширование, перечислите функции хеширования](#org2520270)
53. [53. Перечислите и охарактеризуйте способы разрешения конфликтов при хешировании](#org71baaac)
54. [54. Перечислите методы и способы создания анимации в среде программирования](#org1572061)
55. [55. Раскройте понятие windows-приложение. Назовите стандартные компоненты для разработки приложений](#org37a0e9e)
56. [56. Раскройте понятие пространство имен, его назначение.](#orgd4cb544)
57. [57. Раскройте понятие заголовочный файл, его назначение и использование](#orgcb5a48f)
58. [58. Раскройте понятие двоичное дерево, балансировка двоичного дерева](#orgaaa5756)
59. [59. Раскройте понятие класс, объект, перечислите спецификаторы доступа](#orgba18263)
60. [60. Раскройте понятие массив, особенности передачи массивов в качестве параметров](#org78cbeb7)
61. [61. Раскройте понятие тестирование программного обеспечения. Перечислите и кратко охарактеризуйте основные эпохи тестирования](#org10b1ccd)
62. [62. Раскройте понятие тестирование программного обеспечения. Приведите упрощенную классификацию тестирования](#org422784c)
63. [63. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по запуску кода на исполнение](#orgf1ce8e0)
64. [64. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по доступу к коду и архитектуре приложения](#org6fe190f)
65. [65. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по степени автоматизации](#orgb7a78e9)
66. [66. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по принципам работы с приложением](#orgf99b889)


<a id="org799df60"></a>

# 1. Перечислите и охарактеризуйте стадии разработки программного обеспечения


<a id="org3cb9f01"></a>

## Анализ требований:

-   Описание: Определение требований к программному обеспечению. Включает в себя сбор и анализ информации от клиентов или конечных пользователей для определения того, что должно делать приложение.
-   Цель: Понять, какие функции и задачи должно выполнять ПО.


<a id="orgb104a00"></a>

## Проектирование (дизайн):

-   Описание: Разработка архитектуры и дизайна системы. На этом этапе разрабатываются высокоуровневые и низкоуровневые проектные документы, которые описывают, как будет структурирована система.
-   Цель: Создание четкой и детализированной схемы того, как будет реализовано ПО.


<a id="org5191419"></a>

## Реализация (кодирование):

-   Описание: Написание исходного кода программы на языке C++. Включает в себя реализацию всех функциональных возможностей, описанных на этапе проектирования.
-   Цель: Создание рабочего программного продукта, который соответствует требованиям.


<a id="orga11c5e3"></a>

## Тестирование:

-   Описание: Проверка программного обеспечения на наличие ошибок и дефектов. Включает различные виды тестирования, такие как модульное, интеграционное, системное и приемочное тестирование.
-   Цель: Обеспечение качества и надежности ПО, выявление и устранение ошибок.


<a id="org5018a8f"></a>

## Интеграция и деплоймент:

-   Описание: Внедрение программного обеспечения в рабочую среду. Включает интеграцию с другими системами и развертывание на конечных устройствах.
-   Цель: Доставка ПО конечным пользователям.


<a id="org77d4a5b"></a>

## Эксплуатация и сопровождение:

-   Описание: Поддержка и обновление программного обеспечения в течение его жизненного цикла. Включает исправление ошибок, добавление новых функций и улучшение производительности.
-   Цель: Обеспечение бесперебойной работы и актуальности ПО.


<a id="orgf791b4c"></a>

## Завершение проекта:

-   Описание: Закрытие проекта, архивирование всех документов и кода, анализ завершенного проекта для извлечения уроков на будущее.
-   Цель: Официальное завершение всех проектных работ и оценка их успеха


<a id="org4b88707"></a>

# 2. Раскройте понятие алгоритм, перечислите и охарактеризуйте свойства алгоритмов

**Алгоритм** – это конечная последовательность четко определенных инструкций, предназначенных для решения конкретной задачи или достижения определенной цели. Алгоритмы являются основой компьютерных программ и описывают шаги, которые необходимо выполнить для достижения результата.


<a id="org26a208e"></a>

## Свойства алгоритмов:

1.  Дискретность (пошаговость):

    -   Алгоритм должен быть разбит на отдельные шаги или инструкции, каждая из которых выполняется за конечное время.

2.  Определенность (однозначность):

    -   Каждая инструкция алгоритма должна быть четкой и однозначной, не допуская различных толкований.

3.  Конечность (терминируемость):

    -   Алгоритм должен завершаться после выполнения определенного числа шагов, приводя к результату за конечное время.

4.  Результативность:

    -   Алгоритм должен давать правильный результат после завершения выполнения всех шагов, приводя к решению задачи или достижению цели.

5.  Массовость:

    Алгоритм должен быть применимым к большому числу различных исходных данных, а не только к одному конкретному случаю.


<a id="org7d5a688"></a>

## Примеры некоторых алгоритмов из STL в C++:

**std::sort**: сортировка элементов контейнера.
**std::find**: поиск элемента в контейнере.
**std::for<sub>each</sub>**: применение функции ко всем элементам контейнера.
**std::transform**: применение функции к элементам одного контейнера и сохранение результата в другом.

Пример использования алгоритма  **std::sort** в C++:

    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    int main() 
    {
       std::vector<int> vec = {4, 2, 3, 1, 5};
       std::sort(vec.begin(), vec.end());
       for (int i : vec) {
           std::cout << i << " ";
       }
       return 0;
    }

В этом примере мы используем алгоритм std::sort, чтобы отсортировать элементы вектора по возрастанию.


<a id="orgf1ae721"></a>

# 3. Раскройте понятие алгоритм, перечислите и охарактеризуйте способы описания алгоритмов

**Алгоритм** – это конечная последовательность четко определенных инструкций, предназначенных для решения конкретной задачи или достижения определенной цели. Алгоритмы являются основой компьютерных программ и описывают шаги, которые необходимо выполнить для достижения результата.


<a id="org3bd6264"></a>

### Способы описания алгоритмов на примере C++:

1.  Словесное (текстовое) описание:
    Пример задачи: Найти сумму двух чисел.
    Описание:
    	Введите два числа.
    	Сложите их.
    	Выведите результат.
2.  Пример задачи: Найти максимум из трех чисел.
    Описание:
    	Начало.
    	Ввод трех чисел: a, b, c.
    	Если a > b, то:
    		Если a > c, то максимум = a.
    		Иначе максимум = c.
    	Иначе:
    		Если b > c, то максимум = b.
    		Иначе максимум = c.
    	Вывести максимум.
    	Конец.
3.  Пример задачи на С++ найти сумму элементов массива:
    
        #include <iostream>
        int main() {
            int n;
            std::cout << "Введите количество элементов: ";
            std::cin >> n;
            int arr[n];
            std::cout << "Введите элементы массива: ";
            for (int i = 0; i < n; i++) {
                cin >> arr[i];
            }
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += arr[i];
            }
            std::cout << "Сумма элементов массива: " << sum << std::endl;
            return 0;
        }


<a id="orgc8d5f3f"></a>

# 4. Раскройте понятие алгоритм, перечислите и охарактеризуйте виды алгоритмов

**Алгоритм** – это конечная последовательность четко определенных инструкций, предназначенных для решения конкретной задачи или достижения определенной цели. Алгоритмы являются основой компьютерных программ и описывают шаги, которые необходимо выполнить для достижения результата.


<a id="orga0f4d89"></a>

### Виды алгоритмов и их характеристика:

Алгоритмы можно классифицировать по различным критериям. Основные виды алгоритмов включают:

1.  Линейные алгоритмы

    -   **Описание**: Алгоритмы, в которых все шаги выполняются последовательно один за другим.
    -   **Пример**: Нахождение суммы двух чисел.
    -   **Код на C++**:
    
        #include <iostream>
        int main()
        {
            int a, b, sum;
            std::cout << "Введите два числа: ";
            std:cin >> a >> b;
            sum = a + b;
            std::cout << "Сумма: " << sum << std::endl;
            return 0;
        }

2.  Разветвляющиеся (условные) алгоритмы

    -   **Описание**: Алгоритмы, в которых выполнение шагов зависит от выполнения определенных условий
    -   **Пример**: Проверка числа на четность.
    -   **Код на C++**:
        
            #include <iostream>
            int main() {
                int n;
                std::cout << "Введите число: ";
                std::cin >> n;
                if (n % 2 == 0) {
                    std::cout << n << " - четное число" << std::endl;
                } else {
                    std::cout << n << " - нечетное число" << std::endl;
                }
                return 0;
            }

3.  Циклические алгоритмы

    -   **Описание**: Алгоритмы, в которых одни и те же действия повторяются несколько раз.
    -   **Пример**: Нахождение суммы элементов массива.
    -   **Код на C++**:
        
            #include <iostream>
            int main() {
                int n;
                std::cout << "Введите количество элементов: ";
                std::cin >> n;
            
                int arr[n];
                std::cout << "Введите элементы массива: ";
                for (int i = 0; i < n; i++) {
                    std::cin >> arr[i];
                }
            
                int sum = 0;
                for (int i = 0; i < n; i++) {
                    sum += arr[i];
                }
                std::cout << "Сумма элементов массива: " << sum << std::endl;
                return 0;
            }

4.  Рекурсивные алгоритмы

    -   **Описание**: Алгоритмы, которые вызывают сами себя для решения подзадач
    -   **Пример**: Нахождение факториала числа.
    -   **Код на C++**:
        
            #include <iostream>
            int factorial(int n) {
                if (n <= 1) {
                    return 1;
                } else {
                    return n * factorial(n - 1);
                }
            }
            
            int main() {
                int n;
                std::cout << "Введите число: ";
                std::cin >> n;
                std::cout << "Факториал " << n << " = " << factorial(n) << std::endl;
                return 0;
            }

5.  Алгоритмы деления и завоевания (divide and conquer)

    -   **Описание**: Алгоритмы, которые делят задачу на подзадачи, решают каждую подзадачу рекурсивно, а затем объединяют результаты.
    -   **Пример**: Быстрая сортировка (QuickSort).
    -   **Код на C++**: 
        
            #include <iostream>
            void quicksort(int arr[], int left, int right) {
                int i = left, j = right;
                int pivot = arr[(left + right) / 2];
                while (i <= j) {
                    while (arr[i] < pivot)
                        i++;
                    while (arr[j] > pivot)
                        j--;
                    if (i <= j) {
                        swap(arr[i], arr[j]);
                        i++;
                        j--;
                    }
                }
                if (left < j)
                    quicksort(arr, left, j);
                if (i < right)
                    quicksort(arr, i, right);
            }
            
            int main() {
                int n;
                std::cout << "Введите количество элементов: ";
                std::cin >> n;
            
                int arr[n];
                std::cout << "Введите элементы массива: ";
                for (int i = 0; i < n; i++) {
                    std::cin >> arr[i];
                }
            
                quicksort(arr, 0, n - 1);
            
                cout << "Отсортированный массив: ";
                for (int i = 0; i < n; i++) {
                    std::cout << arr[i] << " ";
                }
                std::cout << std::endl;
                return 0;
            }

6.  Жадные алгоритмы

    -   Описание: Алгоритмы, которые на каждом шагу выбирают локально оптимальное решение, надеясь, что оно приведет к глобально оптимальному решению.
    -   Пример: Задача о размене монет.
    -   Код на C++:
        
            #include <iostream>
            #include <vector>
            void coinChange(vector<int> coins, int amount) {
                vector<int> result;
                for (int i = coins.size() - 1; i >= 0; i--) {
                    while (amount >= coins[i]) {
                        amount -= coins[i];
                        result.push_back(coins[i]);
                    }
                }
                std::cout << "Монеты для размена: ";
                for (int coin : result) {
                    std::cout << coin << " ";
                }
                std::cout << std::endl;
            }
            
            int main() {
                vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 500};
                int amount;
                std::cout << "Введите сумму для размена: ";
                std::cin >> amount;
                coinChange(coins, amount);
                return 0;
            }


<a id="org2766bf0"></a>

# 5. Раскройте понятие тип данных, перечислите основные встроенные типы данных

**Тип данных** – это характеристика данных, которая определяет, какие значения могут быть использованы, 
какие операции можно выполнять над этими значениями, а также как эти значения хранятся в памяти.
Типы данных играют ключевую роль в программировании, обеспечивая структурирование и обработку информации.


<a id="org4dbac64"></a>

### Основные встроенные типы данных в C++

1.  Целочисленные типы:

    -   char: используется для хранения символов и небольших целых чисел (обычно 1 байт)
    -   int: основной тип для хранения целых чисел (обычно 4 байта).
    -   short: используется для хранения небольших целых чисел (обычно 2 байта).
    -   long: используется для хранения больших целых чисел (обычно 4 или 8 байт).
    -   long long: используется для хранения очень больших целых чисел (обычно 8 байт).

2.  Вещественные типы (числа с плавающей точкой):

    -   loat: тип данных для хранения вещественных чисел одинарной точности (обычно 4 байта).
    -   double: тип данных для хранения вещественных чисел двойной точности (обычно 8 байт).
    -   long double: тип данных для хранения вещественных чисел расширенной точности (обычно 8, 12 или 16 байт, в зависимости от реализации).

3.  Логический тип:

    -   bool: тип данных для хранения логических значений (true или false).

4.  Символьные типы:

    -   char: как уже упоминалось, используется для хранения одиночных символов.

5.  Типы для работы с несколькими байтами (wide characters):

    -   wchar<sub>t</sub>: используется для хранения символов, кодируемых несколькими байтами (широкие символы).
    -   char16<sub>t</sub>: используется для хранения символов UTF-16.
    -   char32<sub>t</sub>: используется для хранения символов UTF-32.


<a id="orgc16438b"></a>

### Примеры использования основных типов данных в C++

    #include <iostream>
    int main() {
        // Целочисленные типы
        char a = 'A';
        int b = 123;
        short c = 12345;
        long d = 1234567890;
        long long e = 1234567890123456789;
    
        // Вещественные типы
        float f = 3.14f;
        double g = 2.71828;
        long double h = 1.6180339887;
    
        // Логический тип
        bool i = true;
    
        // Символьные типы
        char j = 'B';
    
        // Широкие символы
        wchar_t k = L'Ж';
        char16_t l = u'好';
        char32_t m = U'😊';
    
        // Вывод значений
        std::cout << "char: " << a << std::endl;
        std::cout << "int: " << b << std::endl;
        std::cout << "short: " << c << std::endl;
        std::cout << "long: " << d << std::endl;
        std::cout << "long long: " << e << std::endl;
    
        std::cout << "float: " << f << std::endl;
        std::cout << "double: " << g << std::endl;
        std::cout << "long double: " << h << std::endl;
    
        std::cout << "bool: " << boolalpha << i << std::endl;
    
        std::cout << "char: " << j << std::endl;
    
        std::wcout << L"wchar_t: " << k << std::endl;
        std::cout << "char16_t: " << l << std::endl; // Будет выводить как int, т.к. консоль не поддерживает utf-16 напрямую
        std::cout << "char32_t: " << m << std::endl; // Будет выводить как int, т.к. консоль не поддерживает utf-32 напрямую
    
        return 0;
    }


<a id="org10ac363"></a>

# 6. Перечислите и охарактеризуйте основные структурные элементы программы

Программы на любом языке программирования, включая C++, состоят из различных структурных элементов, которые обеспечивают организацию и выполнение кода. 
Вот основные структурные элементы программы и их характеристика:


<a id="orga8e4a6f"></a>

### Заголовочные файлы

-   **Описание**: Файлы, которые содержат объявления функций, классов и других конструкций, используемых в программе. Заголовочные файлы обычно имеют расширение .h или .hpp.
-   **Пример**:
    
        #include <iostream>
        #include <vector>

-   **Функция**: Позволяют использовать стандартные библиотеки и разрабатывать модульный код.


<a id="orgc82d60a"></a>

### Пространства имен (namespaces)

-   **Описание**: Механизм для организации кода и предотвращения конфликтов имен. Пространства имен группируют связанные элементы (функции, переменные, классы) под общим именем.
-   **Пример**:
    
        using namespace std;

-   **Функция**: Помогают избежать конфликтов имен и улучшить читаемость кода.


<a id="orgf274095"></a>

### Функции

**Описание**: Блоки кода, которые выполняют определенную задачу и могут быть вызваны из других частей программы. Функции могут принимать параметры и возвращать значения.
**Пример**:

    int add(int a, int b) {
        return a + b;
    }

**Функция**: Повышают модульность и переиспользуемость кода.


<a id="orgc70a252"></a>

### Переменные

**Описание**: Именованные объекты, которые хранят данные. Переменные имеют тип данных, который определяет возможные значения и операции над ними.
**Пример**:

    int x = 5;
    double y = 3.14;

**Функция**: Хранят данные, используемые в программе, и позволяют манипулировать этими данными.


<a id="org2184532"></a>

### Операторы

-   **Описание**: Символы или комбинации символов, которые выполняют операции над переменными и значениями.
-   **Примеры**:
    -   Арифметические операторы: `+, -, *, /, %`
    -   Логические операторы: `&&, ||, !`
    -   Операторы сравнения: `==, !=, <, >, <=, >=`
    -   Присваивающие операторы: `=, +=, -=, *=, /=, %=`

**Функция**: Выполняют операции над данными.


<a id="org25470df"></a>

### Управляющие структуры

-   **Описание**: Конструкции, которые управляют потоком выполнения программы.
-   **Примеры**:

-   **Условные операторы**:

    if (x > 0) {
        cout << "Positive";
    } else {
        cout << "Non-positive";
    }

**Циклы**:

    for (int i = 0; i < 10; ++i) {
        cout << i << " ";
    }

**Операторы выбора**:

    switch (x) {
        case 1:
            cout << "One";
            break;
        case 2:
            cout << "Two";
            break;
        default:
            cout << "Other";
    }

**Функция**: Управляют последовательностью выполнения команд.


<a id="orgcbad15c"></a>

### Классы и объекты

-   **Описание**: Классы определяют типы данных, которые включают данные и функции, работающие с этими данными. Объекты являются экземплярами классов.
-   **Пример**:

    class Rectangle {
    public:
        int width, height;
        int area() {
            return width * height;
        }
    };
    
    int main() {
        Rectangle rect;
        rect.width = 5;
        rect.height = 10;
        cout << "Area: " << rect.area() << endl;
        return 0;
    }

-   **Функция**: Обеспечивают объектно-ориентированный подход к программированию, инкапсуляцию и повторное использование кода.


<a id="org3fad6f3"></a>

### Комментарии

-   **Описание**: Текст, который не выполняется как часть программы и используется для пояснения кода.
-   **Примеры**:

    // Однострочный комментарий
    /* Многострочный
       комментарий */

-   **Функция**: Улучшают читаемость кода и помогают понять логику программы.


<a id="org300894c"></a>

### Константы

-   **Описание**: Именованные значения, которые не могут изменяться во время выполнения программы.
-   **Пример**:

    const double PI = 3.14159;

-   **Функция**: Хранят неизменные значения, повышают ясность и предотвращают случайные изменения.


<a id="org0ae15d5"></a>

### Предпроцессорные директивы

-   **Описание**: Инструкции, которые обрабатываются препроцессором перед компиляцией кода.
-   **Примеры**:

    #include <iostream>
    #define PI 3.14159

-   **Функция**: Управляют процессом компиляции, включают заголовочные файлы, определяют макросы и т.д.


<a id="orged645ba"></a>

# 7. Раскройте понятие оператор, перечислите и охарактеризуйте виды операторов


<a id="org5b7ac0a"></a>

### Понятие оператора

Оператор – это символ или набор символов, которые представляют собой определенную операцию, выполняемую над одним или несколькими операндами (значениями или переменными). Операторы используются для выполнения вычислений, логических операций, сравнения значений и управления потоком выполнения программы.


<a id="org24a8da4"></a>

### Виды операторов и их характеристика

1.  Арифметические операторы

    -   Описание: Выполняют математические операции над числовыми значениями.
    -   Примеры и функции:
        -   `` `+` `` : Сложение двух чисел.
            int sum = a + b;
        
        -   `` `-` `` : Вычитание одного числа из другого.
            int diff = a - b;
        
        -   `` `*` `` : Умножение двух чисел.
            int product = a \* b;
        
        -   `` `/` `` : Деление одного числа на другое.
            int quotient = a / b;
        
        -   `` `%` `` : Остаток от деления одного числа на другое.
            int remainder = a % b;

2.  Операторы присваивания

    -   Описание: Присваивают значение переменной.
    -   Примеры и функции:
        -   `` `=` `` : Присваивание значения переменной.
            int x = 10;
        
        -   `` `+=` `` : Добавление значения к переменной и присваивание результата.
            x += 5; // эквивалентно x = x + 5;
        
        -   `` `-=` `` : Вычитание значения из переменной и присваивание результата.
            x -= 3; // эквивалентно x = x - 3;
        
        -   `` `*=` `` : Умножение переменной на значение и присваивание результата+.
            x \*= 2; // эквивалентно x = x \* 2;
        
        -   `` `/=` `` : Деление переменной на значение и присваивание результата.
            x *= 2; /* эквивалентно x = x / 2;
        
        -   `` `%=` `` : Присваивание остатка от деления переменной на значение.
            x %= 2; // эквивалентно x = x % 2;

3.  Инкремент и декремент

    -   Описание: Увеличивают или уменьшают значение переменной на единицу.
    -   Примеры и функции:
        -   `` `++` `` : Инкремент (увеличение на 1).
            int y = 5;
            y++; // y становится 6
        
        -   `` `--` `` : Декремент (уменьшение на 1).
            int z = 5;
            z&#x2013;; // z становится 4

4.  Операторы сравнения

    -   Описание: Сравнивают два значения и возвращают логическое значение (true или false).
    -   Примеры и функции:
        -   `` `==` `` : Равно.
            if (a == b) { *\* &#x2026; \** }
        
        -   `` `!=` `` : Не равно.
            if (a != b) { *\* &#x2026; \** }
        
        -   `` `<` `` : Меньше.
            if (a < b) { *\* &#x2026; \** }
        
        -   `` `>` `` : Больше.
            if (a > b) { *\* &#x2026; \** }
        
        -   `` `<=` `` : Меньше или равно.
            if (a <= b) { *\* &#x2026; \** }
        
        -   `` `>=` `` : Больше или равно.
            if (a >= b) { *\* &#x2026; \** }

5.  Логические операторы

    -   Описание: Выполняют логические операции над булевыми значениями.
    -   Примеры и функции:
        -   `` `&&` `` : Логическое И (конъюнкция).
            if (a > 0 && b > 0) { *\* &#x2026; \** }
        
        -   `` `||` `` : Логическое ИЛИ (дизъюнкция).
            if (a > 0 || b > 0) { *\* &#x2026; \** }
        
        -   `` `!` `` : Логическое НЕ (инверсия).
            if (!a) { *\* &#x2026; \** }

6.  Побитовые операторы

    -   Описание: Выполняют операции на уровне битов.
    -   Примеры и функции:
        -   `` `&` `` : Побитовое И.
            int c = a & b;
        
        -   `` `|` `` : Побитовое ИЛИ.
            int d = a | b;
        
        -   `` `^` `` : Побитовое исключающее ИЛИ (XOR).
            int e = a ^ b;
        
        -   `` `~` `` : Побитовое НЕ.
            int f = ~a;
        
        -   `` `<<` `` : Левый сдвиг.
            int g = a << 1; // эквивалентно умножению на 2
        
        -   `` `>>` `` : Правый сдвиг.
            int h = a >> 1; // эквивалентно делению на 2

7.  Операторы управления

    -   Описание: Управляют потоком выполнения программы.
    -   Примеры и функции:
        -   `` `if` `` : Условный оператор.
            if (a > b) {
            	cout << "a больше b";
            }
        
        -   `` `else` ``: Альтернативный блок для оператора \`if\`.
            if (a > b) {
            	cout << "a больше b";
            } else {
            	cout << "a не больше b";
            }
        
        -   `` `while` `` : Цикл с предусловием.
            while (a < b) {
            	a++;
            }
        
        -   `` `do while` `` : Цикл с постусловием.
            do {
            	a++;
            } while (a < b);
        
        -   `` `for` `` : Цикл с известным числом итераций.
            for (int i = 0; i < 10; ++i) {
            	cout << i << " ";
            }
        
        -   `` `switch` `` : Оператор выбора.
            switch (a) {
            	case 1:
            		cout << "One";
            		break;
            	case 2:
            		cout << "Two";
            		break;
            	default:
            		cout << "Other";
            }
    
    1.  Операторы ввода/вывода
    
        -   Описание: Обеспечивают ввод данных с клавиатуры и вывод данных на экран.
        -   Примеры и функции:
            -   `` `cin` `` : Оператор ввода.
                
                int x;
                cin >> x;
            
            -   ~\`cout\` : Оператор вывода.
                
                cout << "Value of x: " << x << endl;
    
    2.  Оператор запятая
    
        -   Описание: Вычисляет два выражения и возвращает значение второго.
        -   Примеры и функции:
            
            int a = (x = 1, y = 2); // x становится 1, y становится 2, a становится 2


<a id="org3487c5e"></a>

# 8. Перечислите и приведите примеры операторов организации циклов

В языке программирования C++ есть три основных типа операторов организации циклов, которые позволяют повторять выполнение блока кода до тех пор, пока условие цикла остаётся истинным. 

1.  **Цикл for**
2.  **Цикл while**
3.  **Цикл do while**


<a id="orga5f8f43"></a>

### Цикл for

Цикл for используется, когда известно количество итераций заранее. Он включает в себя инициализацию, условие и итерацию в одной строке.

**Синтаксис**:

    for (инициализация; условие; итерация) {
        // тело цикла
    }

**Пример**:

    #include <iostream>
    int main() {
        for (int i = 0; i < 5; ++i) {
            std::cout << "Итерация: " << i << std::endl;
        }
        return 0;
    }


<a id="org91a0691"></a>

### Цикл while

Цикл while используется, когда количество итераций заранее неизвестно и зависит от выполнения условия.

**Синтаксис**:

    while (условие) {
        // тело цикла
    }

**Пример:**

    #include <iostream>
    int main() {
        int i = 0;
        while (i < 5) {
            std::cout << "Итерация: " << i << std::endl;
            ++i;
        }
        return 0;
    }


<a id="orgcab57ad"></a>

### Цикл do while

Цикл do while похож на цикл while, но отличается тем, что его тело выполнится хотя бы один раз, даже если условие ложное с самого начала.

**Синтаксис:**

    do {
        // тело цикла
    } while (условие);

**Пример**:

    #include <iostream>
    int main() {
        int i = 0;
        do {
            std::cout << "Итерация: " << i << std::endl;
            ++i;
        } while (i < 5);
        return 0;
    }


<a id="org4eb8911"></a>

### Операторы управления циклами

В C++ также существуют операторы, которые помогают управлять выполнением циклов:

1.  break: Прерывает выполнение цикла и выходит из него.
2.  continue: Пропускает оставшуюся часть тела цикла и переходит к следующей итерации.

**Пример с оператором break**:

    #include <iostream>
    int main() {
        for (int i = 0; i < 10; ++i) {
            if (i == 5) {
                break; // Прерываем цикл при i = 5
            }
            std::cout << "Итерация: " << i << std::endl;
        }
        return 0;
    }

**Пример с оператором continue**:

    #include <iostream>
    int main() {
        for (int i = 0; i < 10; ++i) {
            if (i == 5) {
                continue; // Пропускаем итерацию при i = 5
            }
            std::cout << "Итерация: " << i << std::endl;
        }
        return 0;
    }


<a id="org3a06bd0"></a>

# 9. Перечислите и приведите примеры условных операторов

Условные операторы в программировании используются для принятия решений на основе выполнения определенных условий. 
Oсновные условные операторы и примеры их использования:

1.  if-else (если-иначе): выполняет определенный блок кода, если условие истинно, и другой блок кода, если условие ложно.

    #include <iostream>
    
    int main() {
        int x = 10;
        if (x > 5) {
            std::cout << "x больше 5" << std::endl;
        } else {
            std::cout << "x не больше 5" << std::endl;
        }
        return 0;
    }

1.  if-else if-else (если-иначе если-иначе):Позволяет проверять несколько условий последовательно и выполнять соответствующий блок кода при первом истинном условии.
    
        #include <iostream>
        int main() {
            int x = 10;
            if (x > 15) {
                std::cout << "x больше 15" << std::endl;
            } else if (x > 5) {
                std::cout << "x больше 5, но не больше 15" << std::endl;
            } else {
                std::cout << "x не больше 5" << std::endl;
            }
            return 0;
        }

2.  Тернарный оператор: Позволяет записать условие в одной строке.

    #include <iostream>
    using namespace std;
    
    int main() {
        int x = 10;
        string result = (x > 5) ? "больше 5" : "не больше 5";
        std::cout << result << std::endl;
        return 0;
    }

1.  Switch-case: Эта конструкция часто используется для замены множества последовательных условных операторов if-else if-else 
    
        #include <iostream>
        string switch_case(int argument) {
            switch(argument) {
                case 1:
                    return "первый случай";
                case 2:
                    return "второй случай";
                case 3:
                    return "третий случай";
                default:
                    return "нет такого случая";
            }
        }
        
        int main() {
            std::cout << switch_case(2) << std::endl;  // выводит "второй случай"
            return 0;
        }


<a id="org3578599"></a>

# 10. Раскройте понятие итерационный алгоритм, охарактеризуйте порядок выполнения

**Итерационный алгоритм** — это алгоритм, который решает задачу путем повторения одного и того же набора инструкций или операций, называемых итерациями, до достижения желаемого результата. 
Он противоположен рекурсивному алгоритму, который использует вызов функций для повторения операций.


<a id="orgdc397cc"></a>

### Порядок выполнения итерационного алгоритма:

-   Инициализация: Начальные условия или переменные инициализируются до начала цикла

-   Условие продолжения: Определяется условие, при выполнении которого цикл будет продолжаться. Если условие истинно, выполняется тело цикла, если нет — цикл завершается.

-   Тело цикла: Это набор инструкций, который выполняется на каждой итерации цикла.

-   Инкрементация (или декрементация): После выполнения тела цикла происходит изменение состояния переменных, которые используются для проверки условия продолжения цикла (инкрементация или  декрементация).

-   Повторение: Цикл повторяется, начиная с проверки условия продолжения.

-   Завершение: Цикл завершается, когда условие продолжения становится ложным.

Пример простого итерационного алгоритма на C++ для вычисления факториала:

    #include <iostream>
    
    int main() {
        int n = 5;
        int factorial = 1;
    
        for (int i = 1; i <= n; ++i) {
            factorial *= i;
        }
    
        std::cout << "Факториал " << n << " равен " << factorial << std::endl;
        return 0;
    }

**В этом примере**:

-   Инициализация: n и factorial инициализируются.
-   Условие продолжения: Цикл for продолжается, пока i меньше или равно n.
-   Тело цикла: Умножение factorial на текущее значение i.
-   Инкрементация: Увеличение i на 1 после каждой итерации.
-   Повторение: Цикл выполняется от i=1 до i=n.
-   Завершение: После завершения цикла выводится результат вычисления факториала числа n.


<a id="org2d79372"></a>

# 11. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания одномерных массивов

Массив в программировании представляет собой структуру данных, которая хранит фиксированное количество элементов одного типа, расположенных последовательно в памяти. 
Каждый элемент массива доступен по индексу, который указывает на его позицию в массиве.

**Виды массивов:**

1.  **Одномерный массив**: Массив, содержащий элементы одного типа, расположенные в одну строку или столбец.
2.  **Многомерный массив**: Массив, содержащий элементы одного типа, расположенные в виде таблицы или куба (например, двумерный массив, трехмерный массив и т.д.).


<a id="orgcdd2c86"></a>

### Примеры описания одномерных массивов на C++

1.  **Массив целых чисел:**

    #include <iostream>
    using namespace std;
    
    int main() {
        // Одномерный массив целых чисел
        int numbers[5] = {1, 2, 3, 4, 5};
    
        // Вывод элементов массива
        cout << "Элементы массива numbers: ";
        for (int i = 0; i < 5; ++i) {
            cout << numbers[i] << " ";
        }
        cout << endl;
    
        return 0;
    }

В этом примере int numbers[5] — это объявление массива из 5 целых чисел. Элементы инициализируются значениями {1, 2, 3, 4, 5}. Доступ к элементам массива осуществляется по индексу numbers[i], где i — индекс элемента (от 0 до 4 в данном случае).

1.  **Массив строк (массив массивов символов):**

    #include <iostream>
    #include <cstring> // Для работы с функциями строки C
    
    int main() {
        // Одномерный массив строк (массив массивов символов)
        char words[3][10] = {"Hello", "World", "C++"};
    
        // Вывод строк массива
        std::cout << "Строки массива words:" << std::endl;
        for (int i = 0; i < 3; ++i) {
            std::cout << words[i] << std::endl;
        }
    
        return 0;
    }

В этом примере char words[3][10] — это объявление массива из 3 строк, каждая длиной до 9 символов (плюс один символ для завершающего нуля). Элементы инициализируются строками {"Hello", "World", "C++"}. Доступ к каждой строке осуществляется по двум индексам: words[i], где i — индекс строки (от 0 до 2), и j — индекс символа в строке (от 0 до 9).


<a id="org7302659"></a>

# 12. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания массивов массивов

Массив в программировании представляет собой структуру данных, которая хранит фиксированное количество элементов одного типа, расположенных последовательно в памяти. 
Каждый элемент массива доступен по индексу, который указывает на его позицию в массиве.


<a id="org71bc7e4"></a>

### Примеры описания массивов массивов (двумерных массивов) на C++:

**Массив массивов целых чисел:**

    #include <iostream>
    int main() {
        // Массив массивов целых чисел (двумерный массив)
        int matrix[3][3] = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        // Вывод элементов двумерного массива
        std::cout << "Элементы матрицы:" << std::endl;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                std::cout << matrix[i][j] << " ";
            }
            std::cout << std::endl;
        }
        return 0;
    }

В этом примере int matrix[3][3] — это объявление двумерного массива из 3 строк и 3 столбцов. Элементы инициализируются значениями {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}. Доступ к элементам двумерного массива осуществляется по двум индексам: matrix[i][j], где i — индекс строки (от 0 до 2), а j — индекс столбца (от 0 до 2).

**Массив массивов строк (массив массивов символов):**

    #include <iostream>
    int main() {
        // Массив массивов строк (двумерный массив строк)
        const char* words[3][2] = {
            {"Hello", "World"},
            {"C++", "Programming"},
            {"Open", "AI"}
        };
        // Вывод строк двумерного массива
        std::cout << "Строки двумерного массива words:" << std::endl;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 2; ++j) {
                std::cout << words[i][j] << " ";
            }
            std::cout << std::endl;
        }
    
        return 0;
    }

В этом примере const char\* words[3][2] — это объявление двумерного массива из 3 строк и 2 столбцов, где каждый элемент является указателем на строку (массив символов). Элементы инициализируются строками {{"Hello", "World"}, {"C++", "Programming"}, {"Open", "AI"}}. Доступ к каждой строке осуществляется по двум индексам: words[i][j], где i — индекс строки (от 0 до 2), а j — индекс столбца (от 0 до 1).


<a id="org758fde6"></a>

# 13. Раскройте понятие процедура и функция, перечислите ключевые особенности

Процедуры и функции являются основными конструкциями для структурирования кода, выполнения операций и повторного использования логики. Хотя термины "процедура" и "функция" могут иногда использоваться взаимозаменяемо, они имеют различия в некоторых контекстах.
**Процедура:**
**Определение**: Процедура (или подпрограмма) представляет собой блок кода, который выполняет определенные действия или операции, но не возвращает значения.
Ключевые особенности:

-   Отсутствие возвращаемого значения: Процедуры не возвращают значения после выполнения.
-   Использование: Процедуры используются для выполнения действий, таких как вывод на экран, изменение глобальных переменных или выполнение определенной последовательности шагов.
-   Синтаксис: В некоторых языках программирования (например, Pascal) процедуры и функции различаются по синтаксису. В C++ процедуры реализуются как функции с типом возвращаемого значения void.

Пример процедуры на C++:

    #include <iostream>
    // Процедура для вывода сообщения на экран
    void greet() {
        std::cout << "Привет, мир!" << std::endl;
    }
    int main() {
        // Вызов процедуры
        greet();
    
        return 0;
    }

**Функция:**
**Определение:** Функция представляет собой блок кода, который выполняет определенные действия и возвращает значение.
Ключевые особенности:

-   Возвращаемое значение: Функции возвращают значение определенного типа после выполнения.
-   Использование: Функции используются для вычислений, обработки данных и получения результата, который может быть использован в дальнейшем.
-   Синтаксис: Функции имеют определенный тип возвращаемого значения и могут принимать аргументы.

Пример функции на C++:

    #include <iostream>
    // Функция для вычисления суммы двух чисел
    int sum(int a, int b) {
        return a + b;
    }
    int main() {
        int x = 5, y = 3;
        // Вызов функции и сохранение результата
        int result = sum(x, y);
        // Вывод результата
        std::cout << "Сумма " << x << " и " << y << " равна " << result << std::endl;
        return 0;
    }

**Основные отличия между процедурой и функцией:**

-   **Возвращаемое значение:** Процедуры не возвращают значение, функции возвращают значение определенного типа.
-   **Цель использования:** Процедуры используются для выполнения действий без возврата результата, функции — для выполнения операций с возвращением результата.
-   **Тип возвращаемого значения:** У процедур тип возвращаемого значения void, у функций тип возвращаемого значения может быть любым, включая void (для случаев, когда функция не возвращает значение).


<a id="orgdf959e1"></a>

# 14. Раскройте понятие процедура и функция, приведите классификацию параметров

Процедуры и функции являются основными конструкциями для структурирования кода, выполнения операций и повторного использования логики. Хотя термины "процедура" и "функция" могут иногда использоваться взаимозаменяемо, они имеют различия в некоторых контекстах.

**Процедура:**
**Определение**: Процедура (или подпрограмма) представляет собой блок кода, который выполняет определенные действия или операции, но не возвращает значения.
Ключевые особенности:

-   Отсутствие возвращаемого значения: Процедуры не возвращают значения после выполнения.
-   Использование: Процедуры используются для выполнения действий, таких как вывод на экран, изменение глобальных переменных или выполнение определенной последовательности шагов.
-   Синтаксис: В некоторых языках программирования (например, Pascal) процедуры и функции различаются по синтаксису. В C++ процедуры реализуются как функции с типом возвращаемого значения void.

**Функция:**
**Определение:** Функция представляет собой блок кода, который выполняет определенные действия и возвращает значение.
Ключевые особенности:

-   Возвращаемое значение: Функции возвращают значение определенного типа после выполнения.
-   Использование: Функции используются для вычислений, обработки данных и получения результата, который может быть использован в дальнейшем.
-   Синтаксис: Функции имеют определенный тип возвращаемого значения и могут принимать аргументы.

**Классификация параметров:**
Параметры функций и процедур можно классифицировать по различным признакам, таким как направление передачи данных, тип передачи и наличие значений по умолчанию.


<a id="org7bf194f"></a>

### 1. По направлению передачи данных:

-   **Входные параметры (параметры входа, in):** Параметры, значения которых передаются в функцию или процедуру для выполнения вычислений. Значения параметров не изменяются внутри функции или процедуры.
    
        void printMessage(const std::string& message) {
            std::cout << message << std::endl;
        }

-   **Выходные параметры (параметры выхода, out):** Параметры, которые используются для возврата результатов из функции или процедуры. Значения этих параметров устанавливаются внутри функции или процедуры.
    
        void calculateSquare(int number, int& result) {
            result = number * number;
        }

-   **Двусторонние параметры (параметры входа-выхода, inout):** Параметры, которые используются как для передачи входных данных, так и для возврата результатов. Значения этих параметров могут изменяться внутри функции или процедуры.
    
        void increment(int& number) {
            number++;
        }


<a id="org7d8abb5"></a>

### 2. По типу передачи:

-   **Передача по значению:** Параметры передаются в функцию или процедуру путем копирования значений. Изменения, сделанные с параметрами внутри функции или процедуры, не влияют на оригинальные данные.
    
        void multiplyByTwo(int number) {
            number *= 2;
        }

-   **Передача по ссылке:** Параметры передаются в функцию или процедуру по ссылке, что позволяет функции или процедуре изменять оригинальные данные.
    
        void multiplyByTwo(int& number) {
            number *= 2;
        }


<a id="orgb93aafb"></a>

### 3. По наличию значений по умолчанию:

-   **Параметры со значениями по умолчанию:** Параметры, для которых в определении функции или процедуры задаются значения по умолчанию. Если такие параметры не передаются при вызове, используются значения по умолчанию.
    
        void printMessage(const std::string& message, const std::string& prefix = "Info: ") {
            std::cout << prefix << message << std::endl;
        }


<a id="org68183ee"></a>

# 15. Раскройте суть метода пошаговой детализации разработки алгоритмов

Метод пошаговой детализации разработки алгоритмов, также известный как метод поэтапного улучшения или поэтапного уточнения, является подходом к проектированию и разработке программного обеспечения, при котором сложная задача разбивается на более мелкие, более управляемые части. Этот метод помогает в постепенной разработке алгоритмов и программ, начиная с общей концепции и детализируя её до уровня конкретных шагов, которые могут быть легко реализованы в коде.


<a id="orga23fe13"></a>

### Основные шаги метода пошаговой детализации

1.  Определение общей задачи:
    -   Начинаем с описания общей задачи или проблемы, которую нужно решить.
    -   Формулируем основные цели и требования к алгоритму или программе.

2.  Разделение задачи на подзадачи:
    -   Разбиваем общую задачу на более мелкие подзадачи, которые проще решать и которые могут быть решены независимо друг от друга.
    -   Для каждой подзадачи формулируем её цели и требования.

3.  Детализация подзадач:
    -   Для каждой подзадачи разрабатываем детализированный план её выполнения.
    -   Если подзадача оказывается слишком сложной, её можно снова разбить на более мелкие подзадачи и повторить процесс детализации.

4.  Реализация подзадач:
    -   Переходим к реализации каждой подзадачи в коде, начиная с самых простых и переходя к более сложным.
    -   В процессе реализации подзадачи могут быть уточнены и дополнены.

5.  Интеграция и тестирование:
    -   После реализации всех подзадач их интегрируем в единый алгоритм или программу.
    -   Проводим тестирование, чтобы убедиться в правильности работы алгоритма или программы и в соответствии её требованиям.


<a id="org8c81cdc"></a>

### Пример применения метода пошаговой детализации на C++:

Допустим, у нас есть задача: написать программу для вычисления факториала числа. Применим метод пошаговой детализации:

1.  Определение общей задачи:
    -   Необходимо написать программу, которая вычисляет факториал заданного числа.

2.  Разделение задачи на подзадачи:
    -   Ввод числа от пользователя.
    -   Вычисление факториала числа.
    -   Вывод результата.

3.  Детализация подзадач:
    -   Ввод числа от пользователя:
        Запросить число у пользователя.
        Прочитать число с клавиатуры.
    -   Вычисление факториала числа:
        Создать функцию для вычисления факториала.
        В функции реализовать цикл для вычисления факториала.
    -   Вывод результата:
        Вывести результат на экран.

4.  Реализация подзадач:
    
        #include <iostream>
        // Функция для вычисления факториала
        int factorial(int n) {
            int result = 1;
            for (int i = 1; i <= n; ++i) {
                result *= i;
            }
            return result;
        }
        
        int main() {
            int number;
            // Ввод числа от пользователя
            std::cout << "Введите число для вычисления факториала: ";
            std::cin >> number;
            // Вычисление факториала
            int fact = factorial(number);
            // Вывод результата
            std::cout << "Факториал " << number << " равен " << fact << std::endl;
            return 0;
        }

5.  Интеграция и тестирование:
    -   Программа уже интегрирована в единый код.
    -   Тестируем программу с разными значениями, чтобы убедиться в её правильности.


<a id="org96a09c7"></a>

### Преимущества метода пошаговой детализации:

-   **Управляемость**: Разделение задачи на подзадачи делает её более управляемой и понятной.
-   **Модульность**: Позволяет разрабатывать и тестировать части программы независимо друг от друга.
-   **Гибкость**: Процесс детализации может быть адаптирован и изменён по мере необходимости.
-   **Повышение качества**: Уменьшает вероятность ошибок и упрощает процесс отладки.


<a id="orgc8f70f8"></a>

# 16. Раскройте понятие строка и символьная переменная, приведите примеры объявлений


<a id="org8f0128c"></a>

### Строка

Строка представляет собой последовательность символов, заключенных в кавычки. В языке C++ строки могут быть реализованы с использованием массивов символов или с использованием стандартного класса std::string.
**Ключевые особенности:**

-   Строка может содержать любой набор символов, включая пробелы и специальные символы.
-   В C++ строки могут быть изменяемыми (mutable) или неизменяемыми (immutable) в зависимости от используемого подхода.
-   Строки позволяют выполнять различные операции, такие как конкатенация, сравнение, извлечение подстрок и т.д.

Примеры объявлений строк:

1.  С-строки (массивы символов):

    #include <iostream>
    int main() {
        // Объявление строки как массива символов
        char greeting[] = "Hello, world!";
        // Вывод строки
        std::cout << greeting << std::endl;
        return 0;
    }

1.  Строки класса std::string:

    #include <iostream>
    #include <string>
    int main() {
        // Объявление строки с использованием класса std::string
        std::string greeting = "Hello, world!";
        // Вывод строки
        std::cout << greeting << std::endl;
        return 0;
    }


<a id="org47f4954"></a>

### Символьная переменная

Символьная переменная (или переменная типа char) представляет собой отдельный символ и занимает 1 байт памяти.
**Ключевые особенности:**

-   Символьные переменные могут содержать один символ, такой как буква, цифра или специальный символ.
-   Символы заключаются в одинарные кавычки (например, 'A', '1', '%').
-   Символьные переменные могут быть использованы для хранения символов и выполнения операций с ними, таких как арифметические операции с кодами символов.

Примеры объявлений символьных переменных:

    #include <iostream>
    int main() {
        // Объявление символьной переменной
        char letter = 'A';
        char digit = '1';
        char symbol = '%';
    
        // Вывод символьных переменных
        std::cout << "Символ: " << letter << std::endl;
        std::cout << "Цифра: " << digit << std::endl;
        std::cout << "Специальный символ: " << symbol << std::endl;
    
        return 0;
    }


<a id="org38ee1ba"></a>

# 17. Перечислите основные функции обработки строк, приведите пример использования

В языке программирования C++ строки могут быть обработаны с помощью различных функций и методов. Основные функции и методы обработки строк включают:


<a id="org84e4633"></a>

### Основные функции и методы обработки строк:

-   Длина строки (length и size)
-   Конкатенация строк (+ и +=)
-   Извлечение подстроки (substr)
-   Поиск в строке (find, rfind)
-   Сравнение строк (compare)
-   Изменение регистра строк (toupper, tolower)
-   Замена подстроки (replace)
-   Вставка подстроки (insert)
-   Удаление подстроки (erase)
-   Преобразование в C-строку (c<sub>str</sub>)


<a id="orgd45992d"></a>

### Пример использования основных функций обработки строк:

    #include <iostream>
    #include <string>
    #include <algorithm> // для transform
    #include <cctype>    // для toupper и tolower
    
    int main() {
        std::string str1 = "Hello, ";
        std::string str2 = "world!";
    
        // 1. Длина строки
        std::cout << "Длина строки str1: " << str1.length() << std::endl;
        std::cout << "Длина строки str2: " << str2.size() << std::endl;
    
        // 2. Конкатенация строк
        std::string str3 = str1 + str2;
        std::cout << "Конкатенация строк: " << str3 << std::endl;
    
        // 3. Извлечение подстроки
        std::string sub = str3.substr(7, 5);
        std::cout << "Извлечение подстроки: " << sub << std::endl;
    
        // 4. Поиск в строке
        size_t pos = str3.find("world");
        if (pos != std::string::npos) {
            std::cout << "Подстрока 'world' найдена на позиции: " << pos << std::endl;
        } else {
            std::cout << "Подстрока 'world' не найдена" << std::endl;
        }
    
        // 5. Сравнение строк
        if (str1.compare("Hello, ") == 0) {
            std::cout << "Строка str1 равна 'Hello, '" << std::endl;
        } else {
            std::cout << "Строка str1 не равна 'Hello, '" << std::endl;
        }
    
        // 6. Изменение регистра строк
        std::transform(str3.begin(), str3.end(), str3.begin(), ::toupper);
        std::cout << "Строка в верхнем регистре: " << str3 << std::endl;
    
        std::transform(str3.begin(), str3.end(), str3.begin(), ::tolower);
        std::cout << "Строка в нижнем регистре: " << str3 << std::endl;
    
        // 7. Замена подстроки
        str3.replace(7, 5, "C++");
        std::cout << "После замены подстроки: " << str3 << std::endl;
    
        // 8. Вставка подстроки
        str3.insert(7, "beautiful ");
        std::cout << "После вставки подстроки: " << str3 << std::endl;
    
        // 9. Удаление подстроки
        str3.erase(7, 10);
        std::cout << "После удаления подстроки: " << str3 << std::endl;
    
        // 10. Преобразование в C-строку
        const char* cstr = str3.c_str();
        std::cout << "C-строка: " << cstr << std::endl;
    
        return 0;
    }

**Пояснение к примеру:**

-   Длина строки: Функции length и size возвращают количество символов в строке.
-   Конкатенация строк: Оператор + или += используется для объединения строк.
-   Извлечение подстроки: Функция substr извлекает подстроку, начиная с указанной позиции и заданной длины.
-   Поиск в строке: Функция find ищет первое вхождение подстроки и возвращает позицию, или std::string::npos, если подстрока не найдена.
-   Сравнение строк: Функция compare сравнивает строки и возвращает 0, если строки равны.
-   Изменение регистра строк: Функции std::transform и ::toupper/::tolower используются для изменения регистра символов в строке.
-   Замена подстроки: Функция replace заменяет часть строки другой строкой.
-   Вставка подстроки: Функция insert вставляет строку в указанную позицию.
-   Удаление подстроки: Функция erase удаляет часть строки.
-   Преобразование в C-строку: Функция c<sub>str</sub> возвращает указатель на массив символов (C-строку), представляющий строку.


<a id="orgf77e4b9"></a>

# 18. Раскройте понятие множество, перечислите операции над множествами

Можество — это абстрактная математическая концепция, представляющая собой коллекцию уникальных элементов. В программировании множество реализуется как структура данных, которая позволяет хранить уникальные элементы и выполнять различные операции над ними. В C++ для работы с множествами используется стандартный контейнер std::set, который предоставляет эффективные средства для выполнения основных операций над множествами.


<a id="orgceb1578"></a>

## Основные операции над множествами

1 Создание множества
2 Добавление эле
3 Удаление элементов
4 Поиск элементов
5 Объединение множеств
5 Пересечение множеств
6 Разность множеств
7 Симметрическая разность
8 Проверка подмножества
9 Размер множества


<a id="org13dcaf2"></a>

## Пример использования операций над множествами на C++

    #include <iostream>
    #include <set>
    #include <algorithm> // для std::set_union, std::set_intersection, std::set_difference
    
    int main() {
        // 1. Создание множества
        std::set<int> set1;
        std::set<int> set2 = {3, 4, 5, 6};
    
        // 2. Добавление элементов
        set1.insert(1);
        set1.insert(2);
        set1.insert(3);
    
        // 3. Удаление элементов
        set1.erase(2);
    
        // 4. Поиск элементов
        if (set1.find(1) != set1.end()) {
            std::cout << "Элемент 1 найден в множестве set1" << std::endl;
        } else {
            std::cout << "Элемент 1 не найден в множестве set1" << std::endl;
        }
    
        // 5. Объединение множеств
        std::set<int> unionSet;
        std::set_union(set1.begin(), set1.end(), set2.begin(), set2.end(),
                       std::inserter(unionSet, unionSet.begin()));
        std::cout << "Объединение множеств: ";
        for (int elem : unionSet) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    
        // 6. Пересечение множеств
        std::set<int> intersectionSet;
        std::set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(),
                              std::inserter(intersectionSet, intersectionSet.begin()));
        std::cout << "Пересечение множеств: ";
        for (int elem : intersectionSet) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    
        // 7. Разность множеств
        std::set<int> differenceSet;
        std::set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(),
                            std::inserter(differenceSet, differenceSet.begin()));
        std::cout << "Разность множеств (set1 - set2): ";
        for (int elem : differenceSet) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    
        // 8. Симметрическая разность
        std::set<int> symDifferenceSet;
        std::set_symmetric_difference(set1.begin(), set1.end(), set2.begin(), set2.end(),
                                      std::inserter(symDifferenceSet, symDifferenceSet.begin()));
        std::cout << "Симметрическая разность множеств: ";
        for (int elem : symDifferenceSet) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    
        // 9. Проверка подмножества
        bool isSubset = std::includes(set2.begin(), set2.end(), set1.begin(), set1.end());
        std::cout << "set1 является подмножеством set2: " << (isSubset ? "да" : "нет") << std::endl;
    
        // 10. Размер множества
        std::cout << "Размер множества set1: " << set1.size() << std::endl;
    
        return 0;
    }

**Пояснение к примеру:**
1 Создание множества: Множество создается с использованием std::set.
2 Добавление элементов: Используется метод insert для добавления элементов в множество.
3 Удаление элементов: Метод erase удаляет элемент из множества.
4 Поиск элементов: Метод find используется для поиска элемента в множестве.
5 Объединение множеств: Функция std::set<sub>union</sub> объединяет два множества.
6 Пересечение множеств: Функция std::set<sub>intersection</sub> находит общие элементы в двух множествах.
7 Разность множеств: Функция std::set<sub>difference</sub> находит элементы, присутствующие в одном множестве, но отсутствующие в другом.
8 Симметрическая разность: Функция std::set<sub>symmetric</sub><sub>difference</sub> находит элементы, присутствующие в одном из множеств, но не в обоих.
9 Проверка подмножества: Функция std::includes проверяет, является ли одно множество подмножеством другого.

1.  Размер множества: Метод size возвращает количество элементов в множестве.


<a id="org14beaad"></a>

# 19. Раскройте понятие множество, перечислите ключевые особенности множества и мультимножества


<a id="org343c317"></a>

## Множество

Можество — это коллекция уникальных элементов, в которой каждый элемент может появляться только один раз. В программировании множества часто используются для хранения и управления уникальными данными. В C++ множества реализованы с использованием стандартного контейнера std::set.

**Ключевые особенности множества:**

1.  **Уникальность элементов:** Каждый элемент в множестве уникален; дубликаты не допускаются.
2.  **Автоматическая сортировка:** Элементы множества автоматически упорядочены (обычно в порядке возрастания).
3.  **Эффективный поиск:** Поиск, вставка и удаление элементов выполняются за логарифмическое время O(log n).
4.  **Нет прямого доступа по индексу:** Доступ к элементам осуществляется через итераторы, а не по индексам.

**Пример использования множества на C++:**

    #include <iostream>
    #include <set>
    int main() {
        std::set<int> mySet;
    
        // Добавление элементов
        mySet.insert(10);
        mySet.insert(20);
        mySet.insert(30);
    
        // Попытка добавления дубликата
        mySet.insert(20); // Не будет добавлено, так как 20 уже существует в множестве
    
        // Вывод элементов
        std::cout << "Элементы множества: ";
        for (int elem : mySet) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    
        return 0;
    }


<a id="org1d7fdb5"></a>

## Мультимножество

Мльтимножество (multiset) — это коллекция, которая позволяет хранить несколько экземпляров одного и того же элемента. В C++ мультимножества реализованы с использованием стандартного контейнера std::multiset.

**Ключевые особенности мультимножества:**

1.  **Допуск дубликатов:** В мультимножестве могут быть несколько экземпляров одного и того же элемента.
2.  **Автоматическая сортировка:** Элементы мультимножества автоматически упорядочены (обычно в порядке возрастания).
3.  **Эффективный поиск:** Поиск, вставка и удаление элементов выполняются за логарифмическое время O(log n).
4.  **Нет прямого доступа по индексу:** Доступ к элементам осуществляется через итераторы, а не по индексам.

**Пример использования мультимножества на C++:**

    #include <iostream>
    #include <set>
    int main() {
        std::multiset<int> myMultiset;
    
        // Добавление элементов
        myMultiset.insert(10);
        myMultiset.insert(20);
        myMultiset.insert(30);
        myMultiset.insert(20); // Добавление дубликата
    
        // Вывод элементов
        std::cout << "Элементы мультимножества: ";
        for (int elem : myMultiset) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
        return 0;
    }


<a id="org07b8ee2"></a>

# 20. Раскройте понятие строка, перечислите основные операции над строками


<a id="org2ac6055"></a>

### Строка

Строка представляет собой последовательность символов, заключенных в кавычки. В языке C++ строки могут быть реализованы с использованием массивов символов или с использованием стандартного класса std::string.

**Основные операции над строками**

-   Создание и инициализация строк
-   Конкатенация строк
-   Доступ к символам строки
-   Измерение длины строки
-   Извлечение подстроки
-   Поиск в строке
-   Сравнение строк
-   Изменение регистра строки
-   Замена подстроки
-   Вставка подстроки
-   Удаление подстроки
-   Преобразование в C-строку
-   Очистка строки

**Примеры использования операций над строками в C++**

    #include <iostream>
    #include <string>
    #include <algorithm> // для std::transform
    #include <cctype>    // для toupper и tolower
    
    int main() {
        // 1. Создание и инициализация строк
        std::string str1 = "Hello";
        std::string str2 = "World";
        std::string str3 = str1 + ", " + str2 + "!";
    
        std::cout << "Создание и инициализация: " << str3 << std::endl;
    
        // 2. Конкатенация строк
        std::string str4 = str1 + " " + str2;
        std::cout << "Конкатенация строк: " << str4 << std::endl;
    
        // 3. Доступ к символам строки
        char firstChar = str1[0];
        std::cout << "Первый символ строки: " << firstChar << std::endl;
    
        // 4. Измерение длины строки
        std::cout << "Длина строки str1: " << str1.length() << std::endl;
    
        // 5. Извлечение подстроки
        std::string subStr = str3.substr(7, 5);
        std::cout << "Извлечение подстроки: " << subStr << std::endl;
    
        // 6. Поиск в строке
        size_t pos = str3.find("World");
        if (pos != std::string::npos) {
            std::cout << "Подстрока 'World' найдена на позиции: " << pos << std::endl;
        } else {
            std::cout << "Подстрока 'World' не найдена" << std::endl;
        }
    
        // 7. Сравнение строк
        if (str1 == "Hello") {
            std::cout << "Строка str1 равна 'Hello'" << std::endl;
        } else {
            std::cout << "Строка str1 не равна 'Hello'" << std::endl;
        }
    
        // 8. Изменение регистра строки
        std::transform(str3.begin(), str3.end(), str3.begin(), ::toupper);
        std::cout << "Строка в верхнем регистре: " << str3 << std::endl;
    
        std::transform(str3.begin(), str3.end(), str3.begin(), ::tolower);
        std::cout << "Строка в нижнем регистре: " << str3 << std::endl;
    
        // 9. Замена подстроки
        str3.replace(7, 5, "C++");
        std::cout << "После замены подстроки: " << str3 << std::endl;
    
        // 10. Вставка подстроки
        str3.insert(7, "beautiful ");
        std::cout << "После вставки подстроки: " << str3 << std::endl;
    
        // 11. Удаление подстроки
        str3.erase(7, 10);
        std::cout << "После удаления подстроки: " << str3 << std::endl;
    
        // 12. Преобразование в C-строку
        const char* cstr = str3.c_str();
        std::cout << "C-строка: " << cstr << std::endl;
    
        // 13. Очистка строки
        str3.clear();
        std::cout << "После очистки строки: '" << str3 << "'" << std::endl;
    
        return 0;
    }

**Пояснение к примеру:**

1.  Создание и инициализация строк: Строки создаются и инициализируются значениями.
2.  Конкатенация строк: Оператор + используется для объединения строк.
3.  Доступ к символам строки: Используется оператор [] для доступа к символам строки.
4.  Измерение длины строки: Метод length возвращает количество символов в строке.
5.  Извлечение подстроки: Метод substr извлекает подстроку, начиная с указанной позиции и заданной длины.
6.  Поиск в строке: Метод find ищет первое вхождение подстроки и возвращает позицию, или std::string::npos, если подстрока не найдена.
7.  Сравнение строк: Оператор == используется для сравнения строк.
8.  Изменение регистра строки: Функции std::transform и ::toupper/::tolower используются для изменения регистра символов в строке.
9.  Замена подстроки: Метод replace заменяет часть строки другой строкой.
10. Вставка подстроки: Метод insert вставляет строку в указанную позицию.
11. Удаление подстроки: Метод erase удаляет часть строки.
12. Преобразование в C-строку: Метод c<sub>str</sub> возвращает указатель на массив символов (C-строку), представляющий строку.
13. Очистка строки: Метод clear удаляет все символы из строки, делая её пустой.


<a id="org9ae64a9"></a>

# 21. Раскройте понятие сортировка, перечислите виды сортировок.


<a id="org28e1aa1"></a>

## Понятие сортировка

**ортировка** — это процесс упорядочивания элементов в определенном порядке. Элементы могут быть числами, строками или другими объектами, и их упорядочение обычно осуществляется на основе значений, которые они принимают. Сортировка используется в различных областях, таких как обработка данных, поиск информации, оптимизация алгоритмов и так далее.


<a id="org5c15e0a"></a>

## Виды сортировок

Сществует множество алгоритмов сортировки, каждый из которых имеет свои особенности и подходит для различных ситуаций. Вот основные виды сортировок:

1.  Пузырьковая сортировка (Bubble Sort)
2.  Сортировка вставками (Insertion Sort)
3.  Сортировка выбором (Selection Sort)
4.  Сортировка слиянием (Merge Sort)
5.  Быстрая сортировка (Quick Sort)
6.  Сортировка Шелла (Shell Sort)
7.  Пирамидальная сортировка (Heap Sort)
8.  Торговая сортировка (Bucket Sort)
9.  Поразрядная сортировка (Radix Sort)
10. Сортировка подсчетом (Counting Sort)
11. Сортировка деревом (Tree Sort)


<a id="org6feeaa1"></a>

## Краткое описание и примеры алгоритмов сортировки


<a id="org05b092d"></a>

### 1. Пузырьковая сортировка (Bubble Sort)

**Описание:** Сравнивает соседние элементы и меняет их местами, если они стоят в неправильном порядке. Повторяется до тех пор, пока массив не будет отсортирован.
**Пример:**

    void bubbleSort(int arr[], int n) {
        for (int i = 0; i < n-1; i++) {
            for (int j = 0; j < n-i-1; j++) {
                if (arr[j] > arr[j+1]) {
                    std::swap(arr[j], arr[j+1]);
                }
            }
        }
    }


<a id="org1708f23"></a>

### 2. Сортировка вставками (Insertion Sort)

**Описание:** Проходит через массив и вставляет каждый элемент на свое место среди уже отсортированных элементов.
**Пример:**

    void insertionSort(int arr[], int n) {
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }


<a id="org32cf477"></a>

### 3. Сортировка выбором (Selection Sort)

**Описание:** Находит минимальный элемент в массиве и меняет его местами с первым элементом. Затем повторяет этот процесс для подмассива, начинающегося со второго элемента.
**Пример:**

    void selectionSort(int arr[], int n) {
        for (int i = 0; i < n-1; i++) {
            int min_idx = i;
            for (int j = i+1; j < n; j++) {
                if (arr[j] < arr[min_idx]) {
                    min_idx = j;
                }
            }
            std::swap(arr[min_idx], arr[i]);
        }
    }


<a id="org7557bae"></a>

### 4. Сортировка слиянием (Merge Sort)

**Описание:** Делит массив на две половины, сортирует каждую половину, а затем сливает их обратно в отсортированный массив.
**Пример:**

    void merge(int arr[], int l, int m, int r) {
        int n1 = m - l + 1;
        int n2 = r - m;
        int L[n1], R[n2];
    
        for (int i = 0; i < n1; i++) {
            L[i] = arr[l + i];
        }
        for (int j = 0; j < n2; j++) {
            R[j] = arr[m + 1 + j];
        }
    
        int i = 0, j = 0, k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
    
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
    
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
    
    void mergeSort(int arr[], int l, int r) {
        if (l < r) {
            int m = l + (r - l) / 2;
            mergeSort(arr, l, m);
            mergeSort(arr, m + 1, r);
            merge(arr, l, m, r);
        }
    }


<a id="org22e94de"></a>

# 22. Охарактеризуйте сортировку обменом, перечислите основные алгоритмы обменных сортировок


<a id="org7903d19"></a>

## Сортировка обменом

Сортировка обменом — это метод сортировки, который основан на многократном обмене соседних элементов, если они стоят в неправильном порядке. В результате на каждом шаге самые большие элементы "всплывают" в конец массива, а самые маленькие перемещаются к началу. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.


<a id="orga23469e"></a>

## Основные алгоритмы обменных сортировок

1.  Пузырьковая сортировка (Bubble Sort)
2.  Шейкерная сортировка (Cocktail Shaker Sort)
3.  Сортировка Шелла (Shell Sort)
4.  Быстрая сортировка (Quick Sort)


<a id="org896b435"></a>

### 1. Пузырьковая сортировка (Bubble Sort)

Описание: Сравнивает и обменивает соседние элементы, если они стоят в неправильном порядке. Процесс повторяется до тех пор, пока массив не будет отсортирован.
**Пример кода:**

    void bubbleSort(int arr[], int n) {
        for (int i = 0; i < n-1; i++) {
            for (int j = 0; j < n-i-1; j++) {
                if (arr[j] > arr[j+1]) {
                    std::swap(arr[j], arr[j+1]);
                }
            }
        }
    }


<a id="org1a75ae9"></a>

### 2. Шейкерная сортировка (Cocktail Shaker Sort)

Описание: Улучшенный вариант пузырьковой сортировки. Алгоритм проходит по массиву в обоих направлениях: сначала слева направо, затем справа налево, перемещая большие элементы к концу и маленькие элементы к началу массива.
**Пример кода:**

    void cocktailShakerSort(int arr[], int n) {
        bool swapped = true;
        int start = 0;
        int end = n - 1;
    
        while (swapped) {
            swapped = false;
    
            for (int i = start; i < end; ++i) {
                if (arr[i] > arr[i + 1]) {
                    std::swap(arr[i], arr[i + 1]);
                    swapped = true;
                }
            }
    
            if (!swapped)
                break;
    
            swapped = false;
            --end;
    
            for (int i = end - 1; i >= start; --i) {
                if (arr[i] > arr[i + 1]) {
                    std::swap(arr[i], arr[i + 1]);
                    swapped = true;
                }
            }
    
            ++start;
        }
    }


<a id="orgd391f57"></a>

### 3. Сортировка Шелла (Shell Sort)

Описание: Является обобщением сортировки вставками. Элементы сравниваются и обмениваются на определенном расстоянии друг от друга, которое постепенно уменьшается до одного. Это позволяет эффективно перемещать элементы на большие расстояния, улучшая производительность по сравнению с пузырьковой сортировкой.
**Пример кода:**

    void shellSort(int arr[], int n) {
         for (int gap = n / 2; gap > 0; gap /= 2) {
             for (int i = gap; i < n; i++) {
                 int temp = arr[i];
                 int j;
                 for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                     arr[j] = arr[j - gap];
                 }
                 arr[j] = temp;
             }
         }
     }


<a id="orge37cb27"></a>

### 4. Быстрая сортировка (Quick Sort)

Описание: Использует метод "разделяй и властвуй". Выбирается опорный элемент, и массив разделяется на две части: элементы, меньшие опорного, и элементы, большие опорного. Эти части сортируются рекурсивно.
**Пример кода:**

    int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low - 1);
    
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        std::swap(arr[i + 1], arr[high]);
        return (i + 1);
    }
    
    void quickSort(int arr[], int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }


<a id="orgc8601f9"></a>

# 23. Охарактеризуйте сортировку вставками, перечислите основные алгоритмы сортировоквставками


<a id="org94db4b4"></a>

# 24. Охарактеризуйте сортировку выбором, перечислите основные алгоритмы сортировок выбором


<a id="org9da6d09"></a>

# 25. Раскройте понятие структура, приведите пример описания


<a id="org6d26e38"></a>

# 26. Раскройте понятие структура, приведите пример обращения к элементам структуры


<a id="orgc061344"></a>

# 27. Раскройте понятие объединение, приведите пример описания


<a id="org323f529"></a>

# 28. Раскройте понятие объединение, перечислите ключевые отличия от структуры


<a id="org8cefbf9"></a>

# 29. Раскройте понятие перечисление, приведите пример объявления


<a id="orgb72a5ba"></a>

# 30. Раскройте понятие файл, перечислите и охарактеризуйте виды файлов


<a id="org5a71f40"></a>

# 31. Раскройте понятие файл, перечислите и охарактеризуйте способы доступа к файлам


<a id="orga0bb98f"></a>

# 32. Раскройте понятие файл, приведите пример объявления файловой переменной


<a id="orgb2fe350"></a>

# 33. Раскройте понятия рекурсия, шаг рекурсии


<a id="orgc7d89a4"></a>

# 34. Раскройте понятие рекурсия, перечислите виды рекурсивных функций


<a id="orgb754e89"></a>

# 35. Раскройте понятие рекурсия, перечислите ключевые особенности объявления и использования рекурсивных функций


<a id="org0b93730"></a>

# 36. Раскройте понятие объектно-ориентированное программирование, перечислите основные свойства ООП


<a id="org65a737f"></a>

# 37. Перечислите и охарактеризуйте основные свойства ООП


<a id="org541b18f"></a>

# 38. Раскройте понятие класс, приведите пример объявления, охарактеризуйте основные элементы


<a id="org5fac11d"></a>

# 39. Раскройте понятие класс, приведите пример объявления объектов класса и обращения к элементам класса


<a id="org09d18d7"></a>

# 40. Раскройте понятие объект, класс, конструктор, деструктор


<a id="org7bb11cd"></a>

# 41. Раскройте понятие наследование, приведите пример наследования классов


<a id="org08a13c1"></a>

# 42. Охарактеризуйте особенности вызова и передачи аргументов конструктора и деструктора при наследовании


<a id="org9d530df"></a>

# 43. Охарактеризуйте понятие динамическая библиотека, назначение и использование


<a id="org239c0e7"></a>

# 44. Раскройте понятие динамические структуры данных, их назначение и использование


<a id="org8926a10"></a>

# 45. Перечислите динамические структуры данных, охарактеризуйте структуру стек


<a id="org1f28a5b"></a>

# 46. Перечислите динамические структуры данных, охарактеризуйте структуру односвязный список


<a id="orgd3d1054"></a>

# 47. Перечислите динамические структуры данных, охарактеризуйте структуру двусвязный список


<a id="orgdea1fdc"></a>

# 48. Перечислите динамические структуры данных, охарактеризуйте структуру очередь


<a id="orge3bdb70"></a>

# 49. Перечислите динамические структуры данных, охарактеризуйте структуру двоичное дерево


<a id="org41e78e2"></a>

# 50. Перечислите способы обхода деревьев


<a id="org029c16c"></a>

# 51. Перечислите динамические структуры данных, охарактеризуйте структуру кольцо


<a id="org2520270"></a>

# 52. Раскройте понятие хеширование, перечислите функции хеширования


<a id="org71baaac"></a>

# 53. Перечислите и охарактеризуйте способы разрешения конфликтов при хешировании


<a id="org1572061"></a>

# 54. Перечислите методы и способы создания анимации в среде программирования


<a id="org37a0e9e"></a>

# 55. Раскройте понятие windows-приложение. Назовите стандартные компоненты для разработки приложений


<a id="orgd4cb544"></a>

# 56. Раскройте понятие пространство имен, его назначение.


<a id="orgcb5a48f"></a>

# 57. Раскройте понятие заголовочный файл, его назначение и использование


<a id="orgaaa5756"></a>

# 58. Раскройте понятие двоичное дерево, балансировка двоичного дерева


<a id="orgba18263"></a>

# 59. Раскройте понятие класс, объект, перечислите спецификаторы доступа


<a id="org78cbeb7"></a>

# 60. Раскройте понятие массив, особенности передачи массивов в качестве параметров


<a id="org10b1ccd"></a>

# 61. Раскройте понятие тестирование программного обеспечения. Перечислите и кратко охарактеризуйте основные эпохи тестирования


<a id="org422784c"></a>

# 62. Раскройте понятие тестирование программного обеспечения. Приведите упрощенную классификацию тестирования


<a id="orgf1ce8e0"></a>

# 63. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по запуску кода на исполнение


<a id="org6fe190f"></a>

# 64. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по доступу к коду и архитектуре приложения


<a id="orgb7a78e9"></a>

# 65. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по степени автоматизации


<a id="orgf99b889"></a>

# 66. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по принципам работы с приложением

