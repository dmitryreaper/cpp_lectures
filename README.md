
# Вопросы к экзамену

1.  [1. Перечислите и охарактеризуйте стадии разработки программного обеспечения](#org3c9b4d1)
    1.  [Анализ требований:](#org146997d)
    2.  [Проектирование (дизайн):](#org20a60bd)
    3.  [Реализация (кодирование):](#org16c72ea)
    4.  [Тестирование:](#org2690536)
    5.  [Интеграция и деплоймент:](#org0eb8f65)
    6.  [Эксплуатация и сопровождение:](#orgce4c411)
    7.  [Завершение проекта:](#org4d9ad16)
2.  [2. Раскройте понятие алгоритм, перечислите и охарактеризуйте свойства алгоритмов](#org0fa829c)
    1.  [Свойства алгоритмов:](#org515d1c4)
    2.  [Примеры некоторых алгоритмов из STL в C++:](#orgd3b74a4)
3.  [3. Раскройте понятие алгоритм, перечислите и охарактеризуйте способы описания алгоритмов](#orgfc7baba)
        1.  [Способы описания алгоритмов на примере C++:](#org4c8c109)
4.  [4. Раскройте понятие алгоритм, перечислите и охарактеризуйте виды алгоритмов](#org3786ae3)
        1.  [Виды алгоритмов и их характеристика:](#org2e36bb7)
5.  [5. Раскройте понятие тип данных, перечислите основные встроенные типы данных](#org72dd004)
        1.  [Основные встроенные типы данных в C++](#org6e0f85e)
        2.  [Примеры использования основных типов данных в C++](#org5f02df0)
6.  [6. Перечислите и охарактеризуйте основные структурные элементы программы](#orgb438990)
        1.  [Заголовочные файлы](#org671aaac)
        2.  [Пространства имен (namespaces)](#org3b67f3b)
        3.  [Функции](#org23aaac5)
        4.  [Переменные](#orgec37a82)
        5.  [Операторы](#org09ca133)
        6.  [Управляющие структуры](#orgb15e686)
        7.  [Классы и объекты](#org180233f)
        8.  [Комментарии](#org2686c35)
        9.  [Константы](#orgc290880)
        10. [Предпроцессорные директивы](#org631ceac)
7.  [7. Раскройте понятие оператор, перечислите и охарактеризуйте виды операторов](#org6dd6550)
        1.  [Понятие оператора](#org53ddef9)
        2.  [Виды операторов и их характеристика](#orgffda108)
8.  [8. Перечислите и приведите примеры операторов организации циклов](#orgc914ff2)
        1.  [Цикл for](#org6603670)
        2.  [Цикл while](#org5496d52)
        3.  [Цикл do while](#orgddc4a29)
        4.  [Операторы управления циклами](#org72e9e1c)
9.  [9. Перечислите и приведите примеры условных операторов](#org3888e69)
10. [10. Раскройте понятие итерационный алгоритм, охарактеризуйте порядок выполнения](#org58dba30)
        1.  [Порядок выполнения итерационного алгоритма:](#org961d973)
11. [11. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания одномерных массивов](#org79bbb58)
        1.  [Примеры описания одномерных массивов на C++](#org4afcc78)
12. [12. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания массивов массивов](#org88524a2)
        1.  [Примеры описания массивов массивов (двумерных массивов) на C++:](#org5a74e82)
13. [13. Раскройте понятие процедура и функция, перечислите ключевые особенности](#org8ac2383)
14. [14. Раскройте понятие процедура и функция, приведите классификацию параметров](#org9a4c06b)
        1.  [1. По направлению передачи данных:](#org3323a84)
        2.  [2. По типу передачи:](#org99e68df)
        3.  [3. По наличию значений по умолчанию:](#orgc0b55ef)
15. [15. Раскройте суть метода пошаговой детализации разработки алгоритмов](#orgd6cb147)
        1.  [Основные шаги метода пошаговой детализации](#org02c757d)
        2.  [Пример применения метода пошаговой детализации на C++:](#orgf7d0ff7)
        3.  [Преимущества метода пошаговой детализации:](#orgd26d6d3)
16. [16. Раскройте понятие строка и символьная переменная, приведите примеры объявлений](#orge2a21fc)
        1.  [Строка](#orgac24dc6)
        2.  [Символьная переменная](#org779352f)
17. [17. Перечислите основные функции обработки строк, приведите пример использования](#orgbbc9610)
        1.  [Основные функции и методы обработки строк:](#orge074efe)
        2.  [Пример использования основных функций обработки строк:](#org2edfc52)
18. [18. Раскройте понятие множество, перечислите операции над множествами](#org1a9521e)
    1.  [Основные операции над множествами](#orge005bc0)
    2.  [Пример использования операций над множествами на C++](#org3da6bee)
19. [19. Раскройте понятие множество, перечислите ключевые особенности множества и мультимножества](#org56474ad)
    1.  [Множество](#orge914c1a)
    2.  [Мультимножество](#org0b10080)
20. [20. Раскройте понятие строка, перечислите основные операции над строками](#org76ce373)
        1.  [Строка](#org41f9279)
21. [21. Раскройте понятие сортировка, перечислите виды сортировок.](#org79924b3)
22. [22. Охарактеризуйте сортировку обменом, перечислите основные алгоритмы обменных сортировок](#orgca6bc0b)
23. [23. Охарактеризуйте сортировку вставками, перечислите основные алгоритмы сортировоквставками](#org3f40d72)
24. [24. Охарактеризуйте сортировку выбором, перечислите основные алгоритмы сортировок выбором](#org793bd0a)
25. [25. Раскройте понятие структура, приведите пример описания](#org6fa5786)
26. [26. Раскройте понятие структура, приведите пример обращения к элементам структуры](#org7fb5312)
27. [27. Раскройте понятие объединение, приведите пример описания](#org60a52e3)
28. [28. Раскройте понятие объединение, перечислите ключевые отличия от структуры](#org5a5b39f)
29. [29. Раскройте понятие перечисление, приведите пример объявления](#org6d0b7bd)
30. [30. Раскройте понятие файл, перечислите и охарактеризуйте виды файлов](#org31c1f3e)
31. [31. Раскройте понятие файл, перечислите и охарактеризуйте способы доступа к файлам](#org3c40e1e)
32. [32. Раскройте понятие файл, приведите пример объявления файловой переменной](#orgc8a9912)
33. [33. Раскройте понятия рекурсия, шаг рекурсии](#org392e29b)
34. [34. Раскройте понятие рекурсия, перечислите виды рекурсивных функций](#org01e1677)
35. [35. Раскройте понятие рекурсия, перечислите ключевые особенности объявления и использования рекурсивных функций](#orgde5f729)
36. [36. Раскройте понятие объектно-ориентированное программирование, перечислите основные свойства ООП](#orge8b54dd)
37. [37. Перечислите и охарактеризуйте основные свойства ООП](#org994af45)
38. [38. Раскройте понятие класс, приведите пример объявления, охарактеризуйте основные элементы](#org9f5f351)
39. [39. Раскройте понятие класс, приведите пример объявления объектов класса и обращения к элементам класса](#orge5f70e8)
40. [40. Раскройте понятие объект, класс, конструктор, деструктор](#org7858d3e)
41. [41. Раскройте понятие наследование, приведите пример наследования классов](#orgec61ed9)
42. [42. Охарактеризуйте особенности вызова и передачи аргументов конструктора и деструктора при наследовании](#org0744085)
43. [43. Охарактеризуйте понятие динамическая библиотека, назначение и использование](#orgbeda907)
44. [44. Раскройте понятие динамические структуры данных, их назначение и использование](#orgd76eb52)
45. [45. Перечислите динамические структуры данных, охарактеризуйте структуру стек](#org999bd29)
46. [46. Перечислите динамические структуры данных, охарактеризуйте структуру односвязный список](#orgbe5bc6b)
47. [47. Перечислите динамические структуры данных, охарактеризуйте структуру двусвязный список](#org31d00b0)
48. [48. Перечислите динамические структуры данных, охарактеризуйте структуру очередь](#org8f098bd)
49. [49. Перечислите динамические структуры данных, охарактеризуйте структуру двоичное дерево](#orgfdd96e2)
50. [50. Перечислите способы обхода деревьев](#org80673ca)
51. [51. Перечислите динамические структуры данных, охарактеризуйте структуру кольцо](#org950f5bc)
52. [52. Раскройте понятие хеширование, перечислите функции хеширования](#org26c804d)
53. [53. Перечислите и охарактеризуйте способы разрешения конфликтов при хешировании](#org1a3ec43)
54. [54. Перечислите методы и способы создания анимации в среде программирования](#orgeb5a53c)
55. [55. Раскройте понятие windows-приложение. Назовите стандартные компоненты для разработки приложений](#orgee7d77b)
56. [56. Раскройте понятие пространство имен, его назначение.](#org4876972)
57. [57. Раскройте понятие заголовочный файл, его назначение и использование](#org5858053)
58. [58. Раскройте понятие двоичное дерево, балансировка двоичного дерева](#org779c265)
59. [59. Раскройте понятие класс, объект, перечислите спецификаторы доступа](#org601dc92)
60. [60. Раскройте понятие массив, особенности передачи массивов в качестве параметров](#org72dc3d1)
61. [61. Раскройте понятие тестирование программного обеспечения. Перечислите и кратко охарактеризуйте основные эпохи тестирования](#orgeb11ae1)
62. [62. Раскройте понятие тестирование программного обеспечения. Приведите упрощенную классификацию тестирования](#org6fd48e8)
63. [63. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по запуску кода на исполнение](#org8b7c016)
64. [64. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по доступу к коду и архитектуре приложения](#orgbef96bd)
65. [65. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по степени автоматизации](#org37fd6dc)
66. [66. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по принципам работы с приложением](#orgc054b62)


<a id="org3c9b4d1"></a>

# 1. Перечислите и охарактеризуйте стадии разработки программного обеспечения


<a id="org146997d"></a>

## Анализ требований:

-   Описание: Определение требований к программному обеспечению. Включает в себя сбор и анализ информации от клиентов или конечных пользователей для определения того, что должно делать приложение.
-   Цель: Понять, какие функции и задачи должно выполнять ПО.


<a id="org20a60bd"></a>

## Проектирование (дизайн):

-   Описание: Разработка архитектуры и дизайна системы. На этом этапе разрабатываются высокоуровневые и низкоуровневые проектные документы, которые описывают, как будет структурирована система.
-   Цель: Создание четкой и детализированной схемы того, как будет реализовано ПО.


<a id="org16c72ea"></a>

## Реализация (кодирование):

-   Описание: Написание исходного кода программы на языке C++. Включает в себя реализацию всех функциональных возможностей, описанных на этапе проектирования.
-   Цель: Создание рабочего программного продукта, который соответствует требованиям.


<a id="org2690536"></a>

## Тестирование:

-   Описание: Проверка программного обеспечения на наличие ошибок и дефектов. Включает различные виды тестирования, такие как модульное, интеграционное, системное и приемочное тестирование.
-   Цель: Обеспечение качества и надежности ПО, выявление и устранение ошибок.


<a id="org0eb8f65"></a>

## Интеграция и деплоймент:

-   Описание: Внедрение программного обеспечения в рабочую среду. Включает интеграцию с другими системами и развертывание на конечных устройствах.
-   Цель: Доставка ПО конечным пользователям.


<a id="orgce4c411"></a>

## Эксплуатация и сопровождение:

-   Описание: Поддержка и обновление программного обеспечения в течение его жизненного цикла. Включает исправление ошибок, добавление новых функций и улучшение производительности.
-   Цель: Обеспечение бесперебойной работы и актуальности ПО.


<a id="org4d9ad16"></a>

## Завершение проекта:

-   Описание: Закрытие проекта, архивирование всех документов и кода, анализ завершенного проекта для извлечения уроков на будущее.
-   Цель: Официальное завершение всех проектных работ и оценка их успеха


<a id="org0fa829c"></a>

# 2. Раскройте понятие алгоритм, перечислите и охарактеризуйте свойства алгоритмов

**Алгоритм** – это конечная последовательность четко определенных инструкций, предназначенных для решения конкретной задачи или достижения определенной цели. Алгоритмы являются основой компьютерных программ и описывают шаги, которые необходимо выполнить для достижения результата.


<a id="org515d1c4"></a>

## Свойства алгоритмов:

1.  Дискретность (пошаговость):

    -   Алгоритм должен быть разбит на отдельные шаги или инструкции, каждая из которых выполняется за конечное время.

2.  Определенность (однозначность):

    -   Каждая инструкция алгоритма должна быть четкой и однозначной, не допуская различных толкований.

3.  Конечность (терминируемость):

    -   Алгоритм должен завершаться после выполнения определенного числа шагов, приводя к результату за конечное время.

4.  Результативность:

    -   Алгоритм должен давать правильный результат после завершения выполнения всех шагов, приводя к решению задачи или достижению цели.

5.  Массовость:

    Алгоритм должен быть применимым к большому числу различных исходных данных, а не только к одному конкретному случаю.


<a id="orgd3b74a4"></a>

## Примеры некоторых алгоритмов из STL в C++:

**std::sort**: сортировка элементов контейнера.
**std::find**: поиск элемента в контейнере.
**std::for<sub>each</sub>**: применение функции ко всем элементам контейнера.
**std::transform**: применение функции к элементам одного контейнера и сохранение результата в другом.

Пример использования алгоритма  **std::sort** в C++:

    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    int main() 
    {
       std::vector<int> vec = {4, 2, 3, 1, 5};
       std::sort(vec.begin(), vec.end());
       for (int i : vec) {
           std::cout << i << " ";
       }
       return 0;
    }

В этом примере мы используем алгоритм std::sort, чтобы отсортировать элементы вектора по возрастанию.


<a id="orgfc7baba"></a>

# 3. Раскройте понятие алгоритм, перечислите и охарактеризуйте способы описания алгоритмов

**Алгоритм** – это конечная последовательность четко определенных инструкций, предназначенных для решения конкретной задачи или достижения определенной цели. Алгоритмы являются основой компьютерных программ и описывают шаги, которые необходимо выполнить для достижения результата.


<a id="org4c8c109"></a>

### Способы описания алгоритмов на примере C++:

1.  Словесное (текстовое) описание:
    Пример задачи: Найти сумму двух чисел.
    Описание:
    	Введите два числа.
    	Сложите их.
    	Выведите результат.
2.  Пример задачи: Найти максимум из трех чисел.
    Описание:
    	Начало.
    	Ввод трех чисел: a, b, c.
    	Если a > b, то:
    		Если a > c, то максимум = a.
    		Иначе максимум = c.
    	Иначе:
    		Если b > c, то максимум = b.
    		Иначе максимум = c.
    	Вывести максимум.
    	Конец.
3.  Пример задачи на С++ найти сумму элементов массива:
    
        #include <iostream>
        int main() {
            int n;
            std::cout << "Введите количество элементов: ";
            std::cin >> n;
            int arr[n];
            std::cout << "Введите элементы массива: ";
            for (int i = 0; i < n; i++) {
                cin >> arr[i];
            }
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += arr[i];
            }
            std::cout << "Сумма элементов массива: " << sum << std::endl;
            return 0;
        }


<a id="org3786ae3"></a>

# 4. Раскройте понятие алгоритм, перечислите и охарактеризуйте виды алгоритмов

**Алгоритм** – это конечная последовательность четко определенных инструкций, предназначенных для решения конкретной задачи или достижения определенной цели. Алгоритмы являются основой компьютерных программ и описывают шаги, которые необходимо выполнить для достижения результата.


<a id="org2e36bb7"></a>

### Виды алгоритмов и их характеристика:

Алгоритмы можно классифицировать по различным критериям. Основные виды алгоритмов включают:

1.  Линейные алгоритмы

    -   **Описание**: Алгоритмы, в которых все шаги выполняются последовательно один за другим.
    -   **Пример**: Нахождение суммы двух чисел.
    -   **Код на C++**:
    
        #include <iostream>
        int main()
        {
            int a, b, sum;
            std::cout << "Введите два числа: ";
            std:cin >> a >> b;
            sum = a + b;
            std::cout << "Сумма: " << sum << std::endl;
            return 0;
        }

2.  Разветвляющиеся (условные) алгоритмы

    -   **Описание**: Алгоритмы, в которых выполнение шагов зависит от выполнения определенных условий
    -   **Пример**: Проверка числа на четность.
    -   **Код на C++**:
        
            #include <iostream>
            int main() {
                int n;
                std::cout << "Введите число: ";
                std::cin >> n;
                if (n % 2 == 0) {
                    std::cout << n << " - четное число" << std::endl;
                } else {
                    std::cout << n << " - нечетное число" << std::endl;
                }
                return 0;
            }

3.  Циклические алгоритмы

    -   **Описание**: Алгоритмы, в которых одни и те же действия повторяются несколько раз.
    -   **Пример**: Нахождение суммы элементов массива.
    -   **Код на C++**:
        
            #include <iostream>
            int main() {
                int n;
                std::cout << "Введите количество элементов: ";
                std::cin >> n;
            
                int arr[n];
                std::cout << "Введите элементы массива: ";
                for (int i = 0; i < n; i++) {
                    std::cin >> arr[i];
                }
            
                int sum = 0;
                for (int i = 0; i < n; i++) {
                    sum += arr[i];
                }
                std::cout << "Сумма элементов массива: " << sum << std::endl;
                return 0;
            }

4.  Рекурсивные алгоритмы

    -   **Описание**: Алгоритмы, которые вызывают сами себя для решения подзадач
    -   **Пример**: Нахождение факториала числа.
    -   **Код на C++**:
        
            #include <iostream>
            int factorial(int n) {
                if (n <= 1) {
                    return 1;
                } else {
                    return n * factorial(n - 1);
                }
            }
            
            int main() {
                int n;
                std::cout << "Введите число: ";
                std::cin >> n;
                std::cout << "Факториал " << n << " = " << factorial(n) << std::endl;
                return 0;
            }

5.  Алгоритмы деления и завоевания (divide and conquer)

    -   **Описание**: Алгоритмы, которые делят задачу на подзадачи, решают каждую подзадачу рекурсивно, а затем объединяют результаты.
    -   **Пример**: Быстрая сортировка (QuickSort).
    -   **Код на C++**: 
        
            #include <iostream>
            void quicksort(int arr[], int left, int right) {
                int i = left, j = right;
                int pivot = arr[(left + right) / 2];
                while (i <= j) {
                    while (arr[i] < pivot)
                        i++;
                    while (arr[j] > pivot)
                        j--;
                    if (i <= j) {
                        swap(arr[i], arr[j]);
                        i++;
                        j--;
                    }
                }
                if (left < j)
                    quicksort(arr, left, j);
                if (i < right)
                    quicksort(arr, i, right);
            }
            
            int main() {
                int n;
                std::cout << "Введите количество элементов: ";
                std::cin >> n;
            
                int arr[n];
                std::cout << "Введите элементы массива: ";
                for (int i = 0; i < n; i++) {
                    std::cin >> arr[i];
                }
            
                quicksort(arr, 0, n - 1);
            
                cout << "Отсортированный массив: ";
                for (int i = 0; i < n; i++) {
                    std::cout << arr[i] << " ";
                }
                std::cout << std::endl;
                return 0;
            }

6.  Жадные алгоритмы

    -   Описание: Алгоритмы, которые на каждом шагу выбирают локально оптимальное решение, надеясь, что оно приведет к глобально оптимальному решению.
    -   Пример: Задача о размене монет.
    -   Код на C++:
        
            #include <iostream>
            #include <vector>
            void coinChange(vector<int> coins, int amount) {
                vector<int> result;
                for (int i = coins.size() - 1; i >= 0; i--) {
                    while (amount >= coins[i]) {
                        amount -= coins[i];
                        result.push_back(coins[i]);
                    }
                }
                std::cout << "Монеты для размена: ";
                for (int coin : result) {
                    std::cout << coin << " ";
                }
                std::cout << std::endl;
            }
            
            int main() {
                vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 500};
                int amount;
                std::cout << "Введите сумму для размена: ";
                std::cin >> amount;
                coinChange(coins, amount);
                return 0;
            }


<a id="org72dd004"></a>

# 5. Раскройте понятие тип данных, перечислите основные встроенные типы данных

**Тип данных** – это характеристика данных, которая определяет, какие значения могут быть использованы, 
какие операции можно выполнять над этими значениями, а также как эти значения хранятся в памяти.
Типы данных играют ключевую роль в программировании, обеспечивая структурирование и обработку информации.


<a id="org6e0f85e"></a>

### Основные встроенные типы данных в C++

1.  Целочисленные типы:

    -   char: используется для хранения символов и небольших целых чисел (обычно 1 байт)
    -   int: основной тип для хранения целых чисел (обычно 4 байта).
    -   short: используется для хранения небольших целых чисел (обычно 2 байта).
    -   long: используется для хранения больших целых чисел (обычно 4 или 8 байт).
    -   long long: используется для хранения очень больших целых чисел (обычно 8 байт).

2.  Вещественные типы (числа с плавающей точкой):

    -   loat: тип данных для хранения вещественных чисел одинарной точности (обычно 4 байта).
    -   double: тип данных для хранения вещественных чисел двойной точности (обычно 8 байт).
    -   long double: тип данных для хранения вещественных чисел расширенной точности (обычно 8, 12 или 16 байт, в зависимости от реализации).

3.  Логический тип:

    -   bool: тип данных для хранения логических значений (true или false).

4.  Символьные типы:

    -   char: как уже упоминалось, используется для хранения одиночных символов.

5.  Типы для работы с несколькими байтами (wide characters):

    -   wchar<sub>t</sub>: используется для хранения символов, кодируемых несколькими байтами (широкие символы).
    -   char16<sub>t</sub>: используется для хранения символов UTF-16.
    -   char32<sub>t</sub>: используется для хранения символов UTF-32.


<a id="org5f02df0"></a>

### Примеры использования основных типов данных в C++

    #include <iostream>
    int main() {
        // Целочисленные типы
        char a = 'A';
        int b = 123;
        short c = 12345;
        long d = 1234567890;
        long long e = 1234567890123456789;
    
        // Вещественные типы
        float f = 3.14f;
        double g = 2.71828;
        long double h = 1.6180339887;
    
        // Логический тип
        bool i = true;
    
        // Символьные типы
        char j = 'B';
    
        // Широкие символы
        wchar_t k = L'Ж';
        char16_t l = u'好';
        char32_t m = U'😊';
    
        // Вывод значений
        std::cout << "char: " << a << std::endl;
        std::cout << "int: " << b << std::endl;
        std::cout << "short: " << c << std::endl;
        std::cout << "long: " << d << std::endl;
        std::cout << "long long: " << e << std::endl;
    
        std::cout << "float: " << f << std::endl;
        std::cout << "double: " << g << std::endl;
        std::cout << "long double: " << h << std::endl;
    
        std::cout << "bool: " << boolalpha << i << std::endl;
    
        std::cout << "char: " << j << std::endl;
    
        std::wcout << L"wchar_t: " << k << std::endl;
        std::cout << "char16_t: " << l << std::endl; // Будет выводить как int, т.к. консоль не поддерживает utf-16 напрямую
        std::cout << "char32_t: " << m << std::endl; // Будет выводить как int, т.к. консоль не поддерживает utf-32 напрямую
    
        return 0;
    }


<a id="orgb438990"></a>

# 6. Перечислите и охарактеризуйте основные структурные элементы программы

Программы на любом языке программирования, включая C++, состоят из различных структурных элементов, которые обеспечивают организацию и выполнение кода. 
Вот основные структурные элементы программы и их характеристика:


<a id="org671aaac"></a>

### Заголовочные файлы

-   **Описание**: Файлы, которые содержат объявления функций, классов и других конструкций, используемых в программе. Заголовочные файлы обычно имеют расширение .h или .hpp.
-   **Пример**:
    
        #include <iostream>
        #include <vector>

-   **Функция**: Позволяют использовать стандартные библиотеки и разрабатывать модульный код.


<a id="org3b67f3b"></a>

### Пространства имен (namespaces)

-   **Описание**: Механизм для организации кода и предотвращения конфликтов имен. Пространства имен группируют связанные элементы (функции, переменные, классы) под общим именем.
-   **Пример**:
    
        using namespace std;

-   **Функция**: Помогают избежать конфликтов имен и улучшить читаемость кода.


<a id="org23aaac5"></a>

### Функции

**Описание**: Блоки кода, которые выполняют определенную задачу и могут быть вызваны из других частей программы. Функции могут принимать параметры и возвращать значения.
**Пример**:

    int add(int a, int b) {
        return a + b;
    }

**Функция**: Повышают модульность и переиспользуемость кода.


<a id="orgec37a82"></a>

### Переменные

**Описание**: Именованные объекты, которые хранят данные. Переменные имеют тип данных, который определяет возможные значения и операции над ними.
**Пример**:

    int x = 5;
    double y = 3.14;

**Функция**: Хранят данные, используемые в программе, и позволяют манипулировать этими данными.


<a id="org09ca133"></a>

### Операторы

-   **Описание**: Символы или комбинации символов, которые выполняют операции над переменными и значениями.
-   **Примеры**:
    -   Арифметические операторы: +, -, \*, /, %
    -   Логические операторы: &&, ||, !
    -   Операторы сравнения: `=, !`, <, >, <=, >=
    -   Присваивающие операторы: `, +`, -`, *`, /=, %=

**Функция**: Выполняют операции над данными.


<a id="orgb15e686"></a>

### Управляющие структуры

-   **Описание**: Конструкции, которые управляют потоком выполнения программы.
-   **Примеры**:

-   **Условные операторы**:

    if (x > 0) {
        cout << "Positive";
    } else {
        cout << "Non-positive";
    }

**Циклы**:

    for (int i = 0; i < 10; ++i) {
        cout << i << " ";
    }

**Операторы выбора**:

    switch (x) {
        case 1:
            cout << "One";
            break;
        case 2:
            cout << "Two";
            break;
        default:
            cout << "Other";
    }

**Функция**: Управляют последовательностью выполнения команд.


<a id="org180233f"></a>

### Классы и объекты

-   **Описание**: Классы определяют типы данных, которые включают данные и функции, работающие с этими данными. Объекты являются экземплярами классов.
-   **Пример**:

    class Rectangle {
    public:
        int width, height;
        int area() {
            return width * height;
        }
    };
    
    int main() {
        Rectangle rect;
        rect.width = 5;
        rect.height = 10;
        cout << "Area: " << rect.area() << endl;
        return 0;
    }

-   **Функция**: Обеспечивают объектно-ориентированный подход к программированию, инкапсуляцию и повторное использование кода.


<a id="org2686c35"></a>

### Комментарии

-   **Описание**: Текст, который не выполняется как часть программы и используется для пояснения кода.
-   **Примеры**:

    // Однострочный комментарий
    /* Многострочный
       комментарий */

-   **Функция**: Улучшают читаемость кода и помогают понять логику программы.


<a id="orgc290880"></a>

### Константы

-   **Описание**: Именованные значения, которые не могут изменяться во время выполнения программы.
-   **Пример**:

    const double PI = 3.14159;

-   **Функция**: Хранят неизменные значения, повышают ясность и предотвращают случайные изменения.


<a id="org631ceac"></a>

### Предпроцессорные директивы

-   **Описание**: Инструкции, которые обрабатываются препроцессором перед компиляцией кода.
-   **Примеры**:

    #include <iostream>
    #define PI 3.14159

-   **Функция**: Управляют процессом компиляции, включают заголовочные файлы, определяют макросы и т.д.


<a id="org6dd6550"></a>

# 7. Раскройте понятие оператор, перечислите и охарактеризуйте виды операторов


<a id="org53ddef9"></a>

### Понятие оператора

Оператор – это символ или набор символов, которые представляют собой определенную операцию, выполняемую над одним или несколькими операндами (значениями или переменными). Операторы используются для выполнения вычислений, логических операций, сравнения значений и управления потоком выполнения программы.


<a id="orgffda108"></a>

### Виды операторов и их характеристика

1.  Арифметические операторы

    -   Описание: Выполняют математические операции над числовыми значениями.
    -   Примеры и функции:
        -   \`+\` : Сложение двух чисел.
            int sum = a + b;
        
        -   \`-\` : Вычитание одного числа из другого.
            int diff = a - b;
        
        -   \`\*\` : Умножение двух чисел.
            int product = a \* b;
        
        -   \`/\` : Деление одного числа на другое.
            int quotient = a / b;
        
        -   \`%\` : Остаток от деления одного числа на другое.
            int remainder = a % b;

2.  Операторы присваивания

    -   Описание: Присваивают значение переменной.
    -   Примеры и функции:
        -   \`=\` : Присваивание значения переменной.
            int x = 10;
        
        -   \`+=\` : Добавление значения к переменной и присваивание результата.
            x += 5; // эквивалентно x = x + 5;
        
        -   \`-`` ` : Вычитание значения из переменной и присваивание результата.
                x - `` 3; // эквивалентно x = x - 3;
        
        -   \`\*=\` : Умножение переменной на значение и присваивание результата.
            x \*= 2; // эквивалентно x = x \* 2;
        
        -   \`/=\` : Деление переменной на значение и присваивание результата.
            x *= 2; /* эквивалентно x = x / 2;
        
        -   \`%=\` : Присваивание остатка от деления переменной на значение.
            x %= 2; // эквивалентно x = x % 2;

3.  Инкремент и декремент

    -   Описание: Увеличивают или уменьшают значение переменной на единицу.
    -   Примеры и функции:
        -   \`++\` : Инкремент (увеличение на 1).
            int y = 5;
            y++; // y становится 6
        
        -   \`&#x2013;\` : Декремент (уменьшение на 1).
            int z = 5;
            z&#x2013;; // z становится 4

4.  Операторы сравнения

    -   Описание: Сравнивают два значения и возвращают логическое значение (true или false).
    -   Примеры и функции:
        -   \`==\` : Равно.
            if (a == b) { *\* &#x2026; \** }
        
        -   \`!=\` : Не равно.
            if (a != b) { *\* &#x2026; \** }
        
        -   \`<\` : Меньше.
            if (a < b) { *\* &#x2026; \** }
        
        -   \`>\` : Больше.
            if (a > b) { *\* &#x2026; \** }
        
        -   \`<=\` : Меньше или равно.
            if (a <= b) { *\* &#x2026; \** }
        
        -   \`>=\` : Больше или равно.
            if (a >= b) { *\* &#x2026; \** }

5.  Логические операторы

    -   Описание: Выполняют логические операции над булевыми значениями.
    -   Примеры и функции:
        -   \`&&\` : Логическое И (конъюнкция).
            if (a > 0 && b > 0) { *\* &#x2026; \** }
        
        -   \`||\` : Логическое ИЛИ (дизъюнкция).
            if (a > 0 || b > 0) { *\* &#x2026; \** }
        
        -   \`!\` : Логическое НЕ (инверсия).
            if (!a) { *\* &#x2026; \** }

6.  Побитовые операторы

    -   Описание: Выполняют операции на уровне битов.
    -   Примеры и функции:
        -   \`&\` : Побитовое И.
            int c = a & b;
        
        -   \`|\` : Побитовое ИЛИ.
            int d = a | b;
        
        -   \`^\` : Побитовое исключающее ИЛИ (XOR).
            int e = a ^ b;
        
        -   \`~\` : Побитовое НЕ.
            int f = ~a;
        
        -   \`<<\` : Левый сдвиг.
            int g = a << 1; // эквивалентно умножению на 2
        
        -   \`>>\` : Правый сдвиг.
            int h = a >> 1; // эквивалентно делению на 2

7.  Операторы управления

    -   Описание: Управляют потоком выполнения программы.
    -   Примеры и функции:
        -   \`if\` : Условный оператор.
            if (a > b) {
            	cout << "a больше b";
            }
        
        -   \`else\` : Альтернативный блок для оператора \`if\`.
            if (a > b) {
            	cout << "a больше b";
            } else {
            	cout << "a не больше b";
            }
        
        -   \`while\` : Цикл с предусловием.
            while (a < b) {
            	a++;
            }
        
        -   \`do while\` : Цикл с постусловием.
            \`\`\`cpp
            do {
            	a++;
            } while (a < b);
        
        -   \`for\` : Цикл с известным числом итераций.
            \`\`\`cpp
            for (int i = 0; i < 10; ++i) {
            	cout << i << " ";
            }
        
        -   \`switch\` : Оператор выбора.
            
            switch (a) {
            	case 1:
            		cout << "One";
            		break;
            	case 2:
            		cout << "Two";
            		break;
            	default:
            		cout << "Other";
            }
            \`\`\`

8.  Операторы ввода/вывода

    -   Описание: Обеспечивают ввод данных с клавиатуры и вывод данных на экран.
    -   Примеры и функции:
        -   \`cin\` : Оператор ввода.
            
            int x;
            cin >> x;
        
        -   \`cout\` : Оператор вывода.
            
            cout << "Value of x: " << x << endl;

9.  Оператор запятая

    -   Описание: Вычисляет два выражения и возвращает значение второго.
    -   Примеры и функции:
        
        int a = (x = 1, y = 2); // x становится 1, y становится 2, a становится 2


<a id="orgc914ff2"></a>

# 8. Перечислите и приведите примеры операторов организации циклов

В языке программирования C++ есть три основных типа операторов организации циклов, которые позволяют повторять выполнение блока кода до тех пор, пока условие цикла остаётся истинным. 

1.  **Цикл for**
2.  **Цикл while**
3.  **Цикл do while**


<a id="org6603670"></a>

### Цикл for

Цикл for используется, когда известно количество итераций заранее. Он включает в себя инициализацию, условие и итерацию в одной строке.

**Синтаксис**:

    for (инициализация; условие; итерация) {
        // тело цикла
    }

**Пример**:

    #include <iostream>
    int main() {
        for (int i = 0; i < 5; ++i) {
            std::cout << "Итерация: " << i << std::endl;
        }
        return 0;
    }


<a id="org5496d52"></a>

### Цикл while

Цикл while используется, когда количество итераций заранее неизвестно и зависит от выполнения условия.

**Синтаксис**:

    while (условие) {
        // тело цикла
    }

**Пример:**

    #include <iostream>
    int main() {
        int i = 0;
        while (i < 5) {
            std::cout << "Итерация: " << i << std::endl;
            ++i;
        }
        return 0;
    }


<a id="orgddc4a29"></a>

### Цикл do while

Цикл do while похож на цикл while, но отличается тем, что его тело выполнится хотя бы один раз, даже если условие ложное с самого начала.

**Синтаксис:**

    do {
        // тело цикла
    } while (условие);

**Пример**:

    #include <iostream>
    int main() {
        int i = 0;
        do {
            std::cout << "Итерация: " << i << std::endl;
            ++i;
        } while (i < 5);
        return 0;
    }


<a id="org72e9e1c"></a>

### Операторы управления циклами

В C++ также существуют операторы, которые помогают управлять выполнением циклов:

1.  break: Прерывает выполнение цикла и выходит из него.
2.  continue: Пропускает оставшуюся часть тела цикла и переходит к следующей итерации.

**Пример с оператором break**:

    #include <iostream>
    int main() {
        for (int i = 0; i < 10; ++i) {
            if (i == 5) {
                break; // Прерываем цикл при i = 5
            }
            std::cout << "Итерация: " << i << std::endl;
        }
        return 0;
    }

**Пример с оператором continue**:

    #include <iostream>
    int main() {
        for (int i = 0; i < 10; ++i) {
            if (i == 5) {
                continue; // Пропускаем итерацию при i = 5
            }
            std::cout << "Итерация: " << i << std::endl;
        }
        return 0;
    }


<a id="org3888e69"></a>

# 9. Перечислите и приведите примеры условных операторов

Условные операторы в программировании используются для принятия решений на основе выполнения определенных условий. 
Oсновные условные операторы и примеры их использования:

1.  if-else (если-иначе): выполняет определенный блок кода, если условие истинно, и другой блок кода, если условие ложно.

    #include <iostream>
    
    int main() {
        int x = 10;
        if (x > 5) {
            std::cout << "x больше 5" << std::endl;
        } else {
            std::cout << "x не больше 5" << std::endl;
        }
        return 0;
    }

1.  if-else if-else (если-иначе если-иначе):Позволяет проверять несколько условий последовательно и выполнять соответствующий блок кода при первом истинном условии.
    
        #include <iostream>
        int main() {
            int x = 10;
            if (x > 15) {
                std::cout << "x больше 15" << std::endl;
            } else if (x > 5) {
                std::cout << "x больше 5, но не больше 15" << std::endl;
            } else {
                std::cout << "x не больше 5" << std::endl;
            }
            return 0;
        }

2.  Тернарный оператор: Позволяет записать условие в одной строке.

    #include <iostream>
    using namespace std;
    
    int main() {
        int x = 10;
        string result = (x > 5) ? "больше 5" : "не больше 5";
        std::cout << result << std::endl;
        return 0;
    }

1.  Switch-case: Эта конструкция часто используется для замены множества последовательных условных операторов if-else if-else 
    
        #include <iostream>
        string switch_case(int argument) {
            switch(argument) {
                case 1:
                    return "первый случай";
                case 2:
                    return "второй случай";
                case 3:
                    return "третий случай";
                default:
                    return "нет такого случая";
            }
        }
        
        int main() {
            std::cout << switch_case(2) << std::endl;  // выводит "второй случай"
            return 0;
        }


<a id="org58dba30"></a>

# 10. Раскройте понятие итерационный алгоритм, охарактеризуйте порядок выполнения

**Итерационный алгоритм** — это алгоритм, который решает задачу путем повторения одного и того же набора инструкций или операций, называемых итерациями, до достижения желаемого результата. 
Он противоположен рекурсивному алгоритму, который использует вызов функций для повторения операций.


<a id="org961d973"></a>

### Порядок выполнения итерационного алгоритма:

-   Инициализация: Начальные условия или переменные инициализируются до начала цикла

-   Условие продолжения: Определяется условие, при выполнении которого цикл будет продолжаться. Если условие истинно, выполняется тело цикла, если нет — цикл завершается.

-   Тело цикла: Это набор инструкций, который выполняется на каждой итерации цикла.

-   Инкрементация (или декрементация): После выполнения тела цикла происходит изменение состояния переменных, которые используются для проверки условия продолжения цикла (инкрементация или  декрементация).

-   Повторение: Цикл повторяется, начиная с проверки условия продолжения.

-   Завершение: Цикл завершается, когда условие продолжения становится ложным.

Пример простого итерационного алгоритма на C++ для вычисления факториала:

    #include <iostream>
    
    int main() {
        int n = 5;
        int factorial = 1;
    
        for (int i = 1; i <= n; ++i) {
            factorial *= i;
        }
    
        std::cout << "Факториал " << n << " равен " << factorial << std::endl;
        return 0;
    }

**В этом примере**:

-   Инициализация: n и factorial инициализируются.
-   Условие продолжения: Цикл for продолжается, пока i меньше или равно n.
-   Тело цикла: Умножение factorial на текущее значение i.
-   Инкрементация: Увеличение i на 1 после каждой итерации.
-   Повторение: Цикл выполняется от i=1 до i=n.
-   Завершение: После завершения цикла выводится результат вычисления факториала числа n.


<a id="org79bbb58"></a>

# 11. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания одномерных массивов

Массив в программировании представляет собой структуру данных, которая хранит фиксированное количество элементов одного типа, расположенных последовательно в памяти. 
Каждый элемент массива доступен по индексу, который указывает на его позицию в массиве.

**Виды массивов:**

1.  **Одномерный массив**: Массив, содержащий элементы одного типа, расположенные в одну строку или столбец.
2.  **Многомерный массив**: Массив, содержащий элементы одного типа, расположенные в виде таблицы или куба (например, двумерный массив, трехмерный массив и т.д.).


<a id="org4afcc78"></a>

### Примеры описания одномерных массивов на C++

1.  **Массив целых чисел:**

    #include <iostream>
    using namespace std;
    
    int main() {
        // Одномерный массив целых чисел
        int numbers[5] = {1, 2, 3, 4, 5};
    
        // Вывод элементов массива
        cout << "Элементы массива numbers: ";
        for (int i = 0; i < 5; ++i) {
            cout << numbers[i] << " ";
        }
        cout << endl;
    
        return 0;
    }

В этом примере int numbers[5] — это объявление массива из 5 целых чисел. Элементы инициализируются значениями {1, 2, 3, 4, 5}. Доступ к элементам массива осуществляется по индексу numbers[i], где i — индекс элемента (от 0 до 4 в данном случае).

1.  **Массив строк (массив массивов символов):**

    #include <iostream>
    #include <cstring> // Для работы с функциями строки C
    
    int main() {
        // Одномерный массив строк (массив массивов символов)
        char words[3][10] = {"Hello", "World", "C++"};
    
        // Вывод строк массива
        std::cout << "Строки массива words:" << std::endl;
        for (int i = 0; i < 3; ++i) {
            std::cout << words[i] << std::endl;
        }
    
        return 0;
    }

В этом примере char words[3][10] — это объявление массива из 3 строк, каждая длиной до 9 символов (плюс один символ для завершающего нуля). Элементы инициализируются строками {"Hello", "World", "C++"}. Доступ к каждой строке осуществляется по двум индексам: words[i], где i — индекс строки (от 0 до 2), и j — индекс символа в строке (от 0 до 9).


<a id="org88524a2"></a>

# 12. Раскройте понятие массив, перечислите виды массивов, приведите примеры описания массивов массивов

Массив в программировании представляет собой структуру данных, которая хранит фиксированное количество элементов одного типа, расположенных последовательно в памяти. 
Каждый элемент массива доступен по индексу, который указывает на его позицию в массиве.


<a id="org5a74e82"></a>

### Примеры описания массивов массивов (двумерных массивов) на C++:

**Массив массивов целых чисел:**

    #include <iostream>
    int main() {
        // Массив массивов целых чисел (двумерный массив)
        int matrix[3][3] = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        // Вывод элементов двумерного массива
        std::cout << "Элементы матрицы:" << std::endl;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                std::cout << matrix[i][j] << " ";
            }
            std::cout << std::endl;
        }
        return 0;
    }

В этом примере int matrix[3][3] — это объявление двумерного массива из 3 строк и 3 столбцов. Элементы инициализируются значениями {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}. Доступ к элементам двумерного массива осуществляется по двум индексам: matrix[i][j], где i — индекс строки (от 0 до 2), а j — индекс столбца (от 0 до 2).

**Массив массивов строк (массив массивов символов):**

    #include <iostream>
    int main() {
        // Массив массивов строк (двумерный массив строк)
        const char* words[3][2] = {
            {"Hello", "World"},
            {"C++", "Programming"},
            {"Open", "AI"}
        };
        // Вывод строк двумерного массива
        std::cout << "Строки двумерного массива words:" << std::endl;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 2; ++j) {
                std::cout << words[i][j] << " ";
            }
            std::cout << std::endl;
        }
    
        return 0;
    }

В этом примере const char\* words[3][2] — это объявление двумерного массива из 3 строк и 2 столбцов, где каждый элемент является указателем на строку (массив символов). Элементы инициализируются строками {{"Hello", "World"}, {"C++", "Programming"}, {"Open", "AI"}}. Доступ к каждой строке осуществляется по двум индексам: words[i][j], где i — индекс строки (от 0 до 2), а j — индекс столбца (от 0 до 1).


<a id="org8ac2383"></a>

# 13. Раскройте понятие процедура и функция, перечислите ключевые особенности

Процедуры и функции являются основными конструкциями для структурирования кода, выполнения операций и повторного использования логики. Хотя термины "процедура" и "функция" могут иногда использоваться взаимозаменяемо, они имеют различия в некоторых контекстах.
**Процедура:**
**Определение**: Процедура (или подпрограмма) представляет собой блок кода, который выполняет определенные действия или операции, но не возвращает значения.
Ключевые особенности:

-   Отсутствие возвращаемого значения: Процедуры не возвращают значения после выполнения.
-   Использование: Процедуры используются для выполнения действий, таких как вывод на экран, изменение глобальных переменных или выполнение определенной последовательности шагов.
-   Синтаксис: В некоторых языках программирования (например, Pascal) процедуры и функции различаются по синтаксису. В C++ процедуры реализуются как функции с типом возвращаемого значения void.

Пример процедуры на C++:

    #include <iostream>
    // Процедура для вывода сообщения на экран
    void greet() {
        std::cout << "Привет, мир!" << std::endl;
    }
    int main() {
        // Вызов процедуры
        greet();
    
        return 0;
    }

**Функция:**
**Определение:** Функция представляет собой блок кода, который выполняет определенные действия и возвращает значение.
Ключевые особенности:

-   Возвращаемое значение: Функции возвращают значение определенного типа после выполнения.
-   Использование: Функции используются для вычислений, обработки данных и получения результата, который может быть использован в дальнейшем.
-   Синтаксис: Функции имеют определенный тип возвращаемого значения и могут принимать аргументы.

Пример функции на C++:

    #include <iostream>
    // Функция для вычисления суммы двух чисел
    int sum(int a, int b) {
        return a + b;
    }
    int main() {
        int x = 5, y = 3;
        // Вызов функции и сохранение результата
        int result = sum(x, y);
        // Вывод результата
        std::cout << "Сумма " << x << " и " << y << " равна " << result << std::endl;
        return 0;
    }

**Основные отличия между процедурой и функцией:**

-   **Возвращаемое значение:** Процедуры не возвращают значение, функции возвращают значение определенного типа.
-   **Цель использования:** Процедуры используются для выполнения действий без возврата результата, функции — для выполнения операций с возвращением результата.
-   **Тип возвращаемого значения:** У процедур тип возвращаемого значения void, у функций тип возвращаемого значения может быть любым, включая void (для случаев, когда функция не возвращает значение).


<a id="org9a4c06b"></a>

# 14. Раскройте понятие процедура и функция, приведите классификацию параметров

Процедуры и функции являются основными конструкциями для структурирования кода, выполнения операций и повторного использования логики. Хотя термины "процедура" и "функция" могут иногда использоваться взаимозаменяемо, они имеют различия в некоторых контекстах.

**Процедура:**
**Определение**: Процедура (или подпрограмма) представляет собой блок кода, который выполняет определенные действия или операции, но не возвращает значения.
Ключевые особенности:

-   Отсутствие возвращаемого значения: Процедуры не возвращают значения после выполнения.
-   Использование: Процедуры используются для выполнения действий, таких как вывод на экран, изменение глобальных переменных или выполнение определенной последовательности шагов.
-   Синтаксис: В некоторых языках программирования (например, Pascal) процедуры и функции различаются по синтаксису. В C++ процедуры реализуются как функции с типом возвращаемого значения void.

**Функция:**
**Определение:** Функция представляет собой блок кода, который выполняет определенные действия и возвращает значение.
Ключевые особенности:

-   Возвращаемое значение: Функции возвращают значение определенного типа после выполнения.
-   Использование: Функции используются для вычислений, обработки данных и получения результата, который может быть использован в дальнейшем.
-   Синтаксис: Функции имеют определенный тип возвращаемого значения и могут принимать аргументы.

**Классификация параметров:**
Параметры функций и процедур можно классифицировать по различным признакам, таким как направление передачи данных, тип передачи и наличие значений по умолчанию.


<a id="org3323a84"></a>

### 1. По направлению передачи данных:

-   **Входные параметры (параметры входа, in):** Параметры, значения которых передаются в функцию или процедуру для выполнения вычислений. Значения параметров не изменяются внутри функции или процедуры.
    
        void printMessage(const std::string& message) {
            std::cout << message << std::endl;
        }

-   **Выходные параметры (параметры выхода, out):** Параметры, которые используются для возврата результатов из функции или процедуры. Значения этих параметров устанавливаются внутри функции или процедуры.
    
        void calculateSquare(int number, int& result) {
            result = number * number;
        }

-   **Двусторонние параметры (параметры входа-выхода, inout):** Параметры, которые используются как для передачи входных данных, так и для возврата результатов. Значения этих параметров могут изменяться внутри функции или процедуры.
    
        void increment(int& number) {
            number++;
        }


<a id="org99e68df"></a>

### 2. По типу передачи:

-   **Передача по значению:** Параметры передаются в функцию или процедуру путем копирования значений. Изменения, сделанные с параметрами внутри функции или процедуры, не влияют на оригинальные данные.
    
        void multiplyByTwo(int number) {
            number *= 2;
        }

-   **Передача по ссылке:** Параметры передаются в функцию или процедуру по ссылке, что позволяет функции или процедуре изменять оригинальные данные.
    
        void multiplyByTwo(int& number) {
            number *= 2;
        }


<a id="orgc0b55ef"></a>

### 3. По наличию значений по умолчанию:

-   **Параметры со значениями по умолчанию:** Параметры, для которых в определении функции или процедуры задаются значения по умолчанию. Если такие параметры не передаются при вызове, используются значения по умолчанию.
    
        void printMessage(const std::string& message, const std::string& prefix = "Info: ") {
            std::cout << prefix << message << std::endl;
        }


<a id="orgd6cb147"></a>

# 15. Раскройте суть метода пошаговой детализации разработки алгоритмов

Метод пошаговой детализации разработки алгоритмов, также известный как метод поэтапного улучшения или поэтапного уточнения, является подходом к проектированию и разработке программного обеспечения, при котором сложная задача разбивается на более мелкие, более управляемые части. Этот метод помогает в постепенной разработке алгоритмов и программ, начиная с общей концепции и детализируя её до уровня конкретных шагов, которые могут быть легко реализованы в коде.


<a id="org02c757d"></a>

### Основные шаги метода пошаговой детализации

1.  Определение общей задачи:
    -   Начинаем с описания общей задачи или проблемы, которую нужно решить.
    -   Формулируем основные цели и требования к алгоритму или программе.

2.  Разделение задачи на подзадачи:
    -   Разбиваем общую задачу на более мелкие подзадачи, которые проще решать и которые могут быть решены независимо друг от друга.
    -   Для каждой подзадачи формулируем её цели и требования.

3.  Детализация подзадач:
    -   Для каждой подзадачи разрабатываем детализированный план её выполнения.
    -   Если подзадача оказывается слишком сложной, её можно снова разбить на более мелкие подзадачи и повторить процесс детализации.

4.  Реализация подзадач:
    -   Переходим к реализации каждой подзадачи в коде, начиная с самых простых и переходя к более сложным.
    -   В процессе реализации подзадачи могут быть уточнены и дополнены.

5.  Интеграция и тестирование:
    -   После реализации всех подзадач их интегрируем в единый алгоритм или программу.
    -   Проводим тестирование, чтобы убедиться в правильности работы алгоритма или программы и в соответствии её требованиям.


<a id="orgf7d0ff7"></a>

### Пример применения метода пошаговой детализации на C++:

Допустим, у нас есть задача: написать программу для вычисления факториала числа. Применим метод пошаговой детализации:

1.  Определение общей задачи:
    -   Необходимо написать программу, которая вычисляет факториал заданного числа.

2.  Разделение задачи на подзадачи:
    -   Ввод числа от пользователя.
    -   Вычисление факториала числа.
    -   Вывод результата.

3.  Детализация подзадач:
    -   Ввод числа от пользователя:
        Запросить число у пользователя.
        Прочитать число с клавиатуры.
    -   Вычисление факториала числа:
        Создать функцию для вычисления факториала.
        В функции реализовать цикл для вычисления факториала.
    -   Вывод результата:
        Вывести результат на экран.

4.  Реализация подзадач:
    
        #include <iostream>
        // Функция для вычисления факториала
        int factorial(int n) {
            int result = 1;
            for (int i = 1; i <= n; ++i) {
                result *= i;
            }
            return result;
        }
        
        int main() {
            int number;
            // Ввод числа от пользователя
            std::cout << "Введите число для вычисления факториала: ";
            std::cin >> number;
            // Вычисление факториала
            int fact = factorial(number);
            // Вывод результата
            std::cout << "Факториал " << number << " равен " << fact << std::endl;
            return 0;
        }

5.  Интеграция и тестирование:
    -   Программа уже интегрирована в единый код.
    -   Тестируем программу с разными значениями, чтобы убедиться в её правильности.


<a id="orgd26d6d3"></a>

### Преимущества метода пошаговой детализации:

-   **Управляемость**: Разделение задачи на подзадачи делает её более управляемой и понятной.
-   **Модульность**: Позволяет разрабатывать и тестировать части программы независимо друг от друга.
-   **Гибкость**: Процесс детализации может быть адаптирован и изменён по мере необходимости.
-   **Повышение качества**: Уменьшает вероятность ошибок и упрощает процесс отладки.


<a id="orge2a21fc"></a>

# 16. Раскройте понятие строка и символьная переменная, приведите примеры объявлений


<a id="orgac24dc6"></a>

### Строка

Строка представляет собой последовательность символов, заключенных в кавычки. В языке C++ строки могут быть реализованы с использованием массивов символов или с использованием стандартного класса std::string.
**Ключевые особенности:**

-   Строка может содержать любой набор символов, включая пробелы и специальные символы.
-   В C++ строки могут быть изменяемыми (mutable) или неизменяемыми (immutable) в зависимости от используемого подхода.
-   Строки позволяют выполнять различные операции, такие как конкатенация, сравнение, извлечение подстрок и т.д.

Примеры объявлений строк:

1.  С-строки (массивы символов):

    #include <iostream>
    int main() {
        // Объявление строки как массива символов
        char greeting[] = "Hello, world!";
        // Вывод строки
        std::cout << greeting << std::endl;
        return 0;
    }

1.  Строки класса std::string:

    #include <iostream>
    #include <string>
    int main() {
        // Объявление строки с использованием класса std::string
        std::string greeting = "Hello, world!";
        // Вывод строки
        std::cout << greeting << std::endl;
        return 0;
    }


<a id="org779352f"></a>

### Символьная переменная

Символьная переменная (или переменная типа char) представляет собой отдельный символ и занимает 1 байт памяти.
**Ключевые особенности:**

-   Символьные переменные могут содержать один символ, такой как буква, цифра или специальный символ.
-   Символы заключаются в одинарные кавычки (например, 'A', '1', '%').
-   Символьные переменные могут быть использованы для хранения символов и выполнения операций с ними, таких как арифметические операции с кодами символов.

Примеры объявлений символьных переменных:

    #include <iostream>
    int main() {
        // Объявление символьной переменной
        char letter = 'A';
        char digit = '1';
        char symbol = '%';
    
        // Вывод символьных переменных
        std::cout << "Символ: " << letter << std::endl;
        std::cout << "Цифра: " << digit << std::endl;
        std::cout << "Специальный символ: " << symbol << std::endl;
    
        return 0;
    }


<a id="orgbbc9610"></a>

# 17. Перечислите основные функции обработки строк, приведите пример использования

В языке программирования C++ строки могут быть обработаны с помощью различных функций и методов. Основные функции и методы обработки строк включают:


<a id="orge074efe"></a>

### Основные функции и методы обработки строк:

-   Длина строки (length и size)
-   Конкатенация строк (+ и +=)
-   Извлечение подстроки (substr)
-   Поиск в строке (find, rfind)
-   Сравнение строк (compare)
-   Изменение регистра строк (toupper, tolower)
-   Замена подстроки (replace)
-   Вставка подстроки (insert)
-   Удаление подстроки (erase)
-   Преобразование в C-строку (c<sub>str</sub>)


<a id="org2edfc52"></a>

### Пример использования основных функций обработки строк:

    #include <iostream>
    #include <string>
    #include <algorithm> // для transform
    #include <cctype>    // для toupper и tolower
    
    int main() {
        std::string str1 = "Hello, ";
        std::string str2 = "world!";
    
        // 1. Длина строки
        std::cout << "Длина строки str1: " << str1.length() << std::endl;
        std::cout << "Длина строки str2: " << str2.size() << std::endl;
    
        // 2. Конкатенация строк
        std::string str3 = str1 + str2;
        std::cout << "Конкатенация строк: " << str3 << std::endl;
    
        // 3. Извлечение подстроки
        std::string sub = str3.substr(7, 5);
        std::cout << "Извлечение подстроки: " << sub << std::endl;
    
        // 4. Поиск в строке
        size_t pos = str3.find("world");
        if (pos != std::string::npos) {
            std::cout << "Подстрока 'world' найдена на позиции: " << pos << std::endl;
        } else {
            std::cout << "Подстрока 'world' не найдена" << std::endl;
        }
    
        // 5. Сравнение строк
        if (str1.compare("Hello, ") == 0) {
            std::cout << "Строка str1 равна 'Hello, '" << std::endl;
        } else {
            std::cout << "Строка str1 не равна 'Hello, '" << std::endl;
        }
    
        // 6. Изменение регистра строк
        std::transform(str3.begin(), str3.end(), str3.begin(), ::toupper);
        std::cout << "Строка в верхнем регистре: " << str3 << std::endl;
    
        std::transform(str3.begin(), str3.end(), str3.begin(), ::tolower);
        std::cout << "Строка в нижнем регистре: " << str3 << std::endl;
    
        // 7. Замена подстроки
        str3.replace(7, 5, "C++");
        std::cout << "После замены подстроки: " << str3 << std::endl;
    
        // 8. Вставка подстроки
        str3.insert(7, "beautiful ");
        std::cout << "После вставки подстроки: " << str3 << std::endl;
    
        // 9. Удаление подстроки
        str3.erase(7, 10);
        std::cout << "После удаления подстроки: " << str3 << std::endl;
    
        // 10. Преобразование в C-строку
        const char* cstr = str3.c_str();
        std::cout << "C-строка: " << cstr << std::endl;
    
        return 0;
    }

**Пояснение к примеру:**

-   Длина строки: Функции length и size возвращают количество символов в строке.
-   Конкатенация строк: Оператор + или += используется для объединения строк.
-   Извлечение подстроки: Функция substr извлекает подстроку, начиная с указанной позиции и заданной длины.
-   Поиск в строке: Функция find ищет первое вхождение подстроки и возвращает позицию, или std::string::npos, если подстрока не найдена.
-   Сравнение строк: Функция compare сравнивает строки и возвращает 0, если строки равны.
-   Изменение регистра строк: Функции std::transform и ::toupper/::tolower используются для изменения регистра символов в строке.
-   Замена подстроки: Функция replace заменяет часть строки другой строкой.
-   Вставка подстроки: Функция insert вставляет строку в указанную позицию.
-   Удаление подстроки: Функция erase удаляет часть строки.
-   Преобразование в C-строку: Функция c<sub>str</sub> возвращает указатель на массив символов (C-строку), представляющий строку.


<a id="org1a9521e"></a>

# 18. Раскройте понятие множество, перечислите операции над множествами

Можество — это абстрактная математическая концепция, представляющая собой коллекцию уникальных элементов. В программировании множество реализуется как структура данных, которая позволяет хранить уникальные элементы и выполнять различные операции над ними. В C++ для работы с множествами используется стандартный контейнер std::set, который предоставляет эффективные средства для выполнения основных операций над множествами.


<a id="orge005bc0"></a>

## Основные операции над множествами

1 Создание множества
2 Добавление эле
3 Удаление элементов
4 Поиск элементов
5 Объединение множеств
5 Пересечение множеств
6 Разность множеств
7 Симметрическая разность
8 Проверка подмножества
9 Размер множества


<a id="org3da6bee"></a>

## Пример использования операций над множествами на C++

\#begin<sub>src</sub> cpp
 #include <iostream>
 #include <set>
 #include <algorithm> // для std::set<sub>union</sub>, std::set<sub>intersection</sub>, std::set<sub>difference</sub>

int main() {
	// 1. Создание множества
	std::set<int> set1;
	std::set<int> set2 = {3, 4, 5, 6};

// 2. Добавление элементов
set1.insert(1);
set1.insert(2);
set1.insert(3);

// 3. Удаление элементов
set1.erase(2);

// 4. Поиск элементов
if (set1.find(1) != set1.end()) {
	std::cout << "Элемент 1 найден в множестве set1" << std::endl;
} else {
	std::cout << "Элемент 1 не найден в множестве set1" << std::endl;
}

// 5. Объединение множеств
std::set<int> unionSet;
std::set<sub>union</sub>(set1.begin(), set1.end(), set2.begin(), set2.end(),
			   std::inserter(unionSet, unionSet.begin()));
std::cout << "Объединение множеств: ";
for (int elem : unionSet) {
	std::cout << elem << " ";
}
std::cout << std::endl;

// 6. Пересечение множеств
std::set<int> intersectionSet;
std::set<sub>intersection</sub>(set1.begin(), set1.end(), set2.begin(), set2.end(),
					  std::inserter(intersectionSet, intersectionSet.begin()));
std::cout << "Пересечение множеств: ";
for (int elem : intersectionSet) {
	std::cout << elem << " ";
}
std::cout << std::endl;

// 7. Разность множеств
std::set<int> differenceSet;
std::set<sub>difference</sub>(set1.begin(), set1.end(), set2.begin(), set2.end(),
					std::inserter(differenceSet, differenceSet.begin()));
std::cout << "Разность множеств (set1 - set2): ";
for (int elem : differenceSet) {
	std::cout << elem << " ";
}
std::cout << std::endl;

// 8. Симметрическая разность
std::set<int> symDifferenceSet;
std::set<sub>symmetric</sub><sub>difference</sub>(set1.begin(), set1.end(), set2.begin(), set2.end(),
							  std::inserter(symDifferenceSet, symDifferenceSet.begin()));
std::cout << "Симметрическая разность множеств: ";
for (int elem : symDifferenceSet) {
	std::cout << elem << " ";
}
std::cout << std::endl;

// 9. Проверка подмножества
bool isSubset = std::includes(set2.begin(), set2.end(), set1.begin(), set1.end());
std::cout << "set1 является подмножеством set2: " << (isSubset ? "да" : "нет") << std::endl;

// 10. Размер множества
std::cout << "Размер множества set1: " << set1.size() << std::endl;

     return 0;
 }
\#end<sub>src</sub>

**ояснение к примеру:**
1 Создание множества: Множество создается с использованием std::set.
2 Добавление элементов: Используется метод insert для добавления элементов в множество.
3 Удаление элементов: Метод erase удаляет элемент из множества.
4 Поиск элементов: Метод find используется для поиска элемента в множестве.
5 Объединение множеств: Функция std::set<sub>union</sub> объединяет два множества.
6 Пересечение множеств: Функция std::set<sub>intersection</sub> находит общие элементы в двух множествах.
7 Разность множеств: Функция std::set<sub>difference</sub> находит элементы, присутствующие в одном множестве, но отсутствующие в другом.
8 Симметрическая разность: Функция std::set<sub>symmetric</sub><sub>difference</sub> находит элементы, присутствующие в одном из множеств, но не в обоих.
9 Проверка подмножества: Функция std::includes проверяет, является ли одно множество подмножеством другого.

1.  Размер множества: Метод size возвращает количество элементов в множестве.


<a id="org56474ad"></a>

# 19. Раскройте понятие множество, перечислите ключевые особенности множества и мультимножества


<a id="orge914c1a"></a>

## Множество

Можество — это коллекция уникальных элементов, в которой каждый элемент может появляться только один раз. В программировании множества часто используются для хранения и управления уникальными данными. В C++ множества реализованы с использованием стандартного контейнера std::set.

**лючевые особенности множества:**

1.  **Уникальность элементов:** Каждый элемент в множестве уникален; дубликаты не допускаются.
2.  **Автоматическая сортировка:** Элементы множества автоматически упорядочены (обычно в порядке возрастания).
3.  **Эффективный поиск:** Поиск, вставка и удаление элементов выполняются за логарифмическое время O(log n).
4.  **Нет прямого доступа по индексу:** Доступ к элементам осуществляется через итераторы, а не по индексам.

**ример использования множества на C++:**

\#begin<sub>src</sub> cpp
 #include <iostream>
 #include <set>
 int main() {
     std::set<int> mySet;

// Добавление элементов
mySet.insert(10);
mySet.insert(20);
mySet.insert(30);

*/ Попытка добавления дубликата
mySet.insert(20); /* Не будет добавлено, так как 20 уже существует в множестве

// Вывод элементов
std::cout << "Элементы множества: ";
for (int elem : mySet) {
	std::cout << elem << " ";
}
std::cout << std::endl;

     return 0;
 }
\#end<sub>src</sub>


<a id="org0b10080"></a>

## Мультимножество

Мльтимножество (multiset) — это коллекция, которая позволяет хранить несколько экземпляров одного и того же элемента. В C++ мультимножества реализованы с использованием стандартного контейнера std::multiset.

**лючевые особенности мультимножества:**

1.  **Допуск дубликатов:** В мультимножестве могут быть несколько экземпляров одного и того же элемента.
2.  **Автоматическая сортировка:** Элементы мультимножества автоматически упорядочены (обычно в порядке возрастания).
3.  **Эффективный поиск:** Поиск, вставка и удаление элементов выполняются за логарифмическое время O(log n).
4.  **Нет прямого доступа по индексу:** Доступ к элементам осуществляется через итераторы, а не по индексам.

**ример использования мультимножества на C++:**

\#begin<sub>src</sub> cpp
 #include <iostream>
 #include <set>
 int main() {
     std::multiset<int> myMultiset;

*/ Добавление элементов
myMultiset.insert(10);
myMultiset.insert(20);
myMultiset.insert(30);
myMultiset.insert(20); /* Добавление дубликата

     // Вывод элементов
     std::cout << "Элементы мультимножества: ";
     for (int elem : myMultiset) {
         std::cout << elem << " ";
     }
     std::cout << std::endl;
     return 0;
 }
\#end<sub>src</sub>


<a id="org76ce373"></a>

# 20. Раскройте понятие строка, перечислите основные операции над строками


<a id="org41f9279"></a>

### Строка

Строка представляет собой последовательность символов, заключенных в кавычки. В языке C++ строки могут быть реализованы с использованием массивов символов или с использованием стандартного класса std::string.

**Основные операции над строками**

-   Создание и инициализация строк
-   Конкатенация строк
-   Доступ к символам строки
-   Измерение длины строки
-   Извлечение подстроки
-   Поиск в строке
-   Сравнение строк
-   Изменение регистра строки
-   Замена подстроки
-   Вставка подстроки
-   Удаление подстроки
-   Преобразование в C-строку
-   Очистка строки

**Примеры использования операций над строками в C++**

    #include <iostream>
    #include <string>
    #include <algorithm> // для std::transform
    #include <cctype>    // для toupper и tolower
    
    int main() {
        // 1. Создание и инициализация строк
        std::string str1 = "Hello";
        std::string str2 = "World";
        std::string str3 = str1 + ", " + str2 + "!";
    
        std::cout << "Создание и инициализация: " << str3 << std::endl;
    
        // 2. Конкатенация строк
        std::string str4 = str1 + " " + str2;
        std::cout << "Конкатенация строк: " << str4 << std::endl;
    
        // 3. Доступ к символам строки
        char firstChar = str1[0];
        std::cout << "Первый символ строки: " << firstChar << std::endl;
    
        // 4. Измерение длины строки
        std::cout << "Длина строки str1: " << str1.length() << std::endl;
    
        // 5. Извлечение подстроки
        std::string subStr = str3.substr(7, 5);
        std::cout << "Извлечение подстроки: " << subStr << std::endl;
    
        // 6. Поиск в строке
        size_t pos = str3.find("World");
        if (pos != std::string::npos) {
            std::cout << "Подстрока 'World' найдена на позиции: " << pos << std::endl;
        } else {
            std::cout << "Подстрока 'World' не найдена" << std::endl;
        }
    
        // 7. Сравнение строк
        if (str1 == "Hello") {
            std::cout << "Строка str1 равна 'Hello'" << std::endl;
        } else {
            std::cout << "Строка str1 не равна 'Hello'" << std::endl;
        }
    
        // 8. Изменение регистра строки
        std::transform(str3.begin(), str3.end(), str3.begin(), ::toupper);
        std::cout << "Строка в верхнем регистре: " << str3 << std::endl;
    
        std::transform(str3.begin(), str3.end(), str3.begin(), ::tolower);
        std::cout << "Строка в нижнем регистре: " << str3 << std::endl;
    
        // 9. Замена подстроки
        str3.replace(7, 5, "C++");
        std::cout << "После замены подстроки: " << str3 << std::endl;
    
        // 10. Вставка подстроки
        str3.insert(7, "beautiful ");
        std::cout << "После вставки подстроки: " << str3 << std::endl;
    
        // 11. Удаление подстроки
        str3.erase(7, 10);
        std::cout << "После удаления подстроки: " << str3 << std::endl;
    
        // 12. Преобразование в C-строку
        const char* cstr = str3.c_str();
        std::cout << "C-строка: " << cstr << std::endl;
    
        // 13. Очистка строки
        str3.clear();
        std::cout << "После очистки строки: '" << str3 << "'" << std::endl;
    
        return 0;
    }

**Пояснение к примеру:**

1.  Создание и инициализация строк: Строки создаются и инициализируются значениями.
2.  Конкатенация строк: Оператор + используется для объединения строк.
3.  Доступ к символам строки: Используется оператор [] для доступа к символам строки.
4.  Измерение длины строки: Метод length возвращает количество символов в строке.
5.  Извлечение подстроки: Метод substr извлекает подстроку, начиная с указанной позиции и заданной длины.
6.  Поиск в строке: Метод find ищет первое вхождение подстроки и возвращает позицию, или std::string::npos, если подстрока не найдена.
7.  Сравнение строк: Оператор == используется для сравнения строк.
8.  Изменение регистра строки: Функции std::transform и ::toupper/::tolower используются для изменения регистра символов в строке.
9.  Замена подстроки: Метод replace заменяет часть строки другой строкой.
10. Вставка подстроки: Метод insert вставляет строку в указанную позицию.
11. Удаление подстроки: Метод erase удаляет часть строки.
12. Преобразование в C-строку: Метод c<sub>str</sub> возвращает указатель на массив символов (C-строку), представляющий строку.
13. Очистка строки: Метод clear удаляет все символы из строки, делая её пустой.


<a id="org79924b3"></a>

# 21. Раскройте понятие сортировка, перечислите виды сортировок.


<a id="orgca6bc0b"></a>

# 22. Охарактеризуйте сортировку обменом, перечислите основные алгоритмы обменных сортировок


<a id="org3f40d72"></a>

# 23. Охарактеризуйте сортировку вставками, перечислите основные алгоритмы сортировоквставками


<a id="org793bd0a"></a>

# 24. Охарактеризуйте сортировку выбором, перечислите основные алгоритмы сортировок выбором


<a id="org6fa5786"></a>

# 25. Раскройте понятие структура, приведите пример описания


<a id="org7fb5312"></a>

# 26. Раскройте понятие структура, приведите пример обращения к элементам структуры


<a id="org60a52e3"></a>

# 27. Раскройте понятие объединение, приведите пример описания


<a id="org5a5b39f"></a>

# 28. Раскройте понятие объединение, перечислите ключевые отличия от структуры


<a id="org6d0b7bd"></a>

# 29. Раскройте понятие перечисление, приведите пример объявления


<a id="org31c1f3e"></a>

# 30. Раскройте понятие файл, перечислите и охарактеризуйте виды файлов


<a id="org3c40e1e"></a>

# 31. Раскройте понятие файл, перечислите и охарактеризуйте способы доступа к файлам


<a id="orgc8a9912"></a>

# 32. Раскройте понятие файл, приведите пример объявления файловой переменной


<a id="org392e29b"></a>

# 33. Раскройте понятия рекурсия, шаг рекурсии


<a id="org01e1677"></a>

# 34. Раскройте понятие рекурсия, перечислите виды рекурсивных функций


<a id="orgde5f729"></a>

# 35. Раскройте понятие рекурсия, перечислите ключевые особенности объявления и использования рекурсивных функций


<a id="orge8b54dd"></a>

# 36. Раскройте понятие объектно-ориентированное программирование, перечислите основные свойства ООП


<a id="org994af45"></a>

# 37. Перечислите и охарактеризуйте основные свойства ООП


<a id="org9f5f351"></a>

# 38. Раскройте понятие класс, приведите пример объявления, охарактеризуйте основные элементы


<a id="orge5f70e8"></a>

# 39. Раскройте понятие класс, приведите пример объявления объектов класса и обращения к элементам класса


<a id="org7858d3e"></a>

# 40. Раскройте понятие объект, класс, конструктор, деструктор


<a id="orgec61ed9"></a>

# 41. Раскройте понятие наследование, приведите пример наследования классов


<a id="org0744085"></a>

# 42. Охарактеризуйте особенности вызова и передачи аргументов конструктора и деструктора при наследовании


<a id="orgbeda907"></a>

# 43. Охарактеризуйте понятие динамическая библиотека, назначение и использование


<a id="orgd76eb52"></a>

# 44. Раскройте понятие динамические структуры данных, их назначение и использование


<a id="org999bd29"></a>

# 45. Перечислите динамические структуры данных, охарактеризуйте структуру стек


<a id="orgbe5bc6b"></a>

# 46. Перечислите динамические структуры данных, охарактеризуйте структуру односвязный список


<a id="org31d00b0"></a>

# 47. Перечислите динамические структуры данных, охарактеризуйте структуру двусвязный список


<a id="org8f098bd"></a>

# 48. Перечислите динамические структуры данных, охарактеризуйте структуру очередь


<a id="orgfdd96e2"></a>

# 49. Перечислите динамические структуры данных, охарактеризуйте структуру двоичное дерево


<a id="org80673ca"></a>

# 50. Перечислите способы обхода деревьев


<a id="org950f5bc"></a>

# 51. Перечислите динамические структуры данных, охарактеризуйте структуру кольцо


<a id="org26c804d"></a>

# 52. Раскройте понятие хеширование, перечислите функции хеширования


<a id="org1a3ec43"></a>

# 53. Перечислите и охарактеризуйте способы разрешения конфликтов при хешировании


<a id="orgeb5a53c"></a>

# 54. Перечислите методы и способы создания анимации в среде программирования


<a id="orgee7d77b"></a>

# 55. Раскройте понятие windows-приложение. Назовите стандартные компоненты для разработки приложений


<a id="org4876972"></a>

# 56. Раскройте понятие пространство имен, его назначение.


<a id="org5858053"></a>

# 57. Раскройте понятие заголовочный файл, его назначение и использование


<a id="org779c265"></a>

# 58. Раскройте понятие двоичное дерево, балансировка двоичного дерева


<a id="org601dc92"></a>

# 59. Раскройте понятие класс, объект, перечислите спецификаторы доступа


<a id="org72dc3d1"></a>

# 60. Раскройте понятие массив, особенности передачи массивов в качестве параметров


<a id="orgeb11ae1"></a>

# 61. Раскройте понятие тестирование программного обеспечения. Перечислите и кратко охарактеризуйте основные эпохи тестирования


<a id="org6fd48e8"></a>

# 62. Раскройте понятие тестирование программного обеспечения. Приведите упрощенную классификацию тестирования


<a id="org8b7c016"></a>

# 63. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по запуску кода на исполнение


<a id="orgbef96bd"></a>

# 64. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по доступу к коду и архитектуре приложения


<a id="org37fd6dc"></a>

# 65. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по степени автоматизации


<a id="orgc054b62"></a>

# 66. Раскройте понятие тестирование программного обеспечения. Перечислите и охарактеризуйте виды тестирования по принципам работы с приложением

